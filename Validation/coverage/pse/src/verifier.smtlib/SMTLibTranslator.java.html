<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>SMTLibTranslator.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Merged (08.03.2012 02:43:23)</a> &gt; <a href="../../index.html" class="el_group">pse</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.html" class="el_package">verifier.smtlib</a> &gt; <span class="el_source">SMTLibTranslator.java</span></div><h1>SMTLibTranslator.java</h1><pre class="source lang-java linenums">package verifier.smtlib;

import ast.*;
import misc.Pair;
import verifier.KindOfProgram;

import java.util.*;

/**
 * This class translates a program given as AST into the smtlib format that can
 * be given to certain verifiers.
 */
<span class="fc" id="L13">public class SMTLibTranslator implements ASTVisitor {</span>
    /**
     * list of descriptions for the programs
     */
    private LinkedList&lt;Pair&lt;KindOfProgram, Position&gt;&gt; descriptions;
    /**
     * temporarily saves the list of all programs,
     * i.e. a list of all contracts to be verified
     */
    private ArrayList&lt;LinkedList&lt;S_Expression&gt;&gt; programs;
    /**
     * Keeps track of all arrays that need to be defined.
     */
    private static LinkedList&lt;S_Expression&gt; arrays;
    /**
     * temporarily saves the current expression
     */
    private S_Expression tempExpr;
    /**
     * temporarily saves the number of the current program
     */
    private S_Expression currentProgram;
<span class="fc" id="L35">    private LinkedList&lt;S_Expression&gt; functionAssumes = new LinkedList&lt;S_Expression&gt;();</span>

    /**
     * Translates the given AST into a formula
     * and returns a WPProgram that contains all contracts to be verified.
     *
     * @param ast given AST
     * @return WPProgram of all contracts to be verified
     */
    public WPProgram getWPTree(ASTRoot ast) {
<span class="fc" id="L45">        programs = new ArrayList&lt;LinkedList&lt;S_Expression&gt;&gt;();</span>
<span class="fc" id="L46">        descriptions = new LinkedList&lt;Pair&lt;KindOfProgram, Position&gt;&gt;();</span>
<span class="fc" id="L47">        arrays = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L48">        ast.accept(this);</span>
<span class="fc" id="L49">        LinkedList&lt;S_Expression&gt; result = prepareFinalProgram(programs);</span>
<span class="fc" id="L50">        int size = result.size();</span>
<span class="fc" id="L51">        return new WPProgram(result.toArray(new S_Expression[size]));</span>
    }

    /**
     * Returns a list of program descriptions.
     * @return list of program descriptions
     */
    public LinkedList&lt;Pair&lt;KindOfProgram, Position&gt;&gt; getDescriptions() {
<span class="fc" id="L59">        return descriptions;</span>
    }

    /**
     * Prepares the final program after the most translations.
     * @param programs programs to be prepared to form the final program
     * @return final program
     */
    private static LinkedList&lt;S_Expression&gt; prepareFinalProgram(ArrayList&lt;LinkedList&lt;S_Expression&gt;&gt; programs) {
<span class="fc" id="L68">        ListIterator&lt;LinkedList&lt;S_Expression&gt;&gt; i = programs.listIterator();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        while(i.hasNext()) {</span>
<span class="fc" id="L70">           createBlock(i.next());</span>
        }
<span class="fc" id="L72">        i = programs.listIterator();</span>
        ListIterator&lt;S_Expression&gt; j;
<span class="fc" id="L74">        LinkedList&lt;S_Expression&gt; result = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        while(i.hasNext()) {</span>
<span class="fc" id="L76">            j = i.next().listIterator();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            while(j.hasNext()) {</span>
<span class="fc" id="L78">                result.add(j.next());</span>
            }
        }
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for (S_Expression array : arrays) result.addFirst(array);</span>
<span class="fc" id="L82">        result.addFirst(new S_Expression(&quot;set-logic&quot;,</span>
<span class="fc" id="L83">                new Constant(&quot;AUFNIRA&quot;)));</span>
<span class="fc" id="L84">        return result;</span>
    }

    /**
     * Creates a block, i.e. a single contract to be verified.
     * @param program program to be formed to the final block
     */
    private static void createBlock(LinkedList&lt;S_Expression&gt; program) {
<span class="fc" id="L92">        LinkedList&lt;VarDef&gt; vars = program.getLast().getUndefinedVars();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        for (VarDef var : vars) {</span>
<span class="fc" id="L94">            program.addFirst(new S_Expression(&quot;declare-fun&quot;,</span>
<span class="fc" id="L95">                    new Constant(var.getFullRepresentation())));</span>
        }
<span class="fc" id="L97">        program.addFirst(new Constant(&quot;(push)&quot;));</span>
<span class="fc" id="L98">        program.addLast(new Constant(&quot;(check-sat)&quot;));</span>
<span class="fc" id="L99">        program.addLast(new Constant(&quot;(get-model)&quot;));</span>
<span class="fc" id="L100">        program.addLast(new Constant(&quot;(pop)&quot;));</span>
<span class="fc" id="L101">    }</span>

    /**
     * Returns the string representation of the given type
     * @param type given type
     * @return string representation of the given type
     */
    public static String getTypeString(Type type) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (type instanceof IntegerType) return &quot;Int&quot;;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        else if (type instanceof BooleanType) return &quot;Bool&quot;;</span>
        else {
<span class="fc" id="L112">            Type t = type;</span>
<span class="fc" id="L113">            StringBuilder result = new StringBuilder().append(&quot;(&quot;);</span>
<span class="fc" id="L114">            int n = 0;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            while (t instanceof ArrayType) {</span>
<span class="fc" id="L116">                t = ((ArrayType) t).getType();</span>
<span class="fc" id="L117">                result.append(&quot;(p&quot;).append(n).append(' ').append(&quot;Int)&quot;);</span>
<span class="fc" id="L118">                n += 1;</span>
            }
<span class="fc" id="L120">            result.append(&quot;)&quot;).append(getTypeString(t));</span>
<span class="fc" id="L121">            return result.toString();</span>
        }
    }

    @Override
    public void visit(Conditional conditional) {
<span class="fc" id="L127">        S_Expression saveProgram = currentProgram;</span>
<span class="fc" id="L128">        conditional.getCondition().accept(this);</span>
<span class="fc" id="L129">        S_Expression condition = tempExpr;</span>
<span class="fc" id="L130">        currentProgram = saveProgram.deepCopy();</span>
<span class="fc" id="L131">        conditional.getTrueConditionBody().accept(this);</span>
<span class="fc" id="L132">        S_Expression trueBranch = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L133">                condition.deepCopy(), currentProgram);</span>
<span class="fc" id="L134">        currentProgram = saveProgram.deepCopy();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (conditional.getFalseConditionBody() != null) {</span>
<span class="fc" id="L136">            conditional.getFalseConditionBody().accept(this);</span>
        }
<span class="fc" id="L138">        S_Expression falseBranch = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L139">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L140">                        condition), currentProgram);</span>
<span class="fc" id="L141">        currentProgram = new S_Expression(&quot;or&quot;,</span>
<span class="fc" id="L142">                trueBranch, falseBranch);</span>
<span class="fc" id="L143">    }</span>

    @Override
    public void visit(Loop loop) {
<span class="fc" id="L147">        Ensure[] ensures = loop.getPostconditions();</span>
        //ensures=&gt;rest
<span class="fc" id="L149">        LinkedList&lt;S_Expression&gt; program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L150">        program.add(currentProgram);</span>
<span class="fc" id="L151">        programs.add(program);</span>
<span class="fc" id="L152">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L153">                KindOfProgram.WhileEnsureToRemainingProgram, loop.getPosition()));</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (Ensure ensure : ensures) {</span>
<span class="fc" id="L155">            ensure.accept(this);</span>
<span class="fc" id="L156">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L157">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L159">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L160">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L161">                        program.getLast())));</span>
        //invariants &amp; !condition =&gt; ensures
<span class="fc" id="L163">        program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L164">        programs.add(program);</span>
<span class="fc" id="L165">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L166">                KindOfProgram.InvariantAndNotConditionToWhileEnsure, loop.getPosition()));</span>
<span class="fc" id="L167">        program.add(new Constant(&quot;true&quot;));</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (Ensure ensure : ensures) {</span>
<span class="fc" id="L169">            ensure.accept(this);</span>
<span class="fc" id="L170">            program.set(program.size() - 1, new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L171">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L173">        Invariant[] invariants = loop.getInvariants();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L175">            invariant.accept(this);</span>
<span class="fc" id="L176">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L177">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L179">        functionAssumes = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L180">        loop.getCondition().accept(this);</span>
<span class="fc" id="L181">        program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L182">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L183">                        tempExpr), program.getLast()));</span>
<span class="fc" id="L184">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L185">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L186">                        program.getLast())));</span>
        //invariants &amp; condition =&gt; invariant
<span class="fc" id="L188">        currentProgram = new Constant(&quot;true&quot;);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L190">            invariant.accept(this);</span>
<span class="fc" id="L191">            currentProgram =  new S_Expression(&quot;and&quot;, tempExpr, currentProgram);</span>
        }
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (S_Expression assume : functionAssumes) {</span>
<span class="fc" id="L194">            currentProgram = new S_Expression(&quot;and&quot;, assume, currentProgram);</span>
        }
<span class="fc" id="L196">        loop.getLoopBody().accept(this);</span>
<span class="fc" id="L197">        program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L198">        programs.add(program);</span>
<span class="fc" id="L199">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L200">                KindOfProgram.InvariantAndConditionToInvariant, loop.getPosition()));</span>
<span class="fc" id="L201">        program.add(currentProgram);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L203">            invariant.accept(this);</span>
<span class="fc" id="L204">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L205">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L207">        functionAssumes = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L208">        loop.getCondition().accept(this);</span>
<span class="fc" id="L209">        program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L210">                tempExpr, program.getLast()));</span>
<span class="fc" id="L211">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L212">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L213">                        program.getLast())));</span>
        //pre=&gt;invariants
<span class="fc" id="L215">        currentProgram = new Constant(&quot;true&quot;);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L217">            invariant.accept(this);</span>
<span class="fc" id="L218">            currentProgram = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L219">                    tempExpr, currentProgram);</span>
        }
<span class="fc" id="L221">    }</span>

    @Override
    public void visit(ArrayAssignment arrayAssignment) {
<span class="fc" id="L225">        arrayAssignment.getValue().accept(this);</span>
<span class="fc" id="L226">        String name = arrayAssignment.getIdentifier().getName();</span>
<span class="fc" id="L227">        int depth = arrayAssignment.getDepth();</span>
<span class="fc" id="L228">        VarDef var = arrayVar(arrayAssignment.getPosition(), name, arrayAssignment.getType(), depth);</span>
<span class="fc" id="L229">        String variable = var.toString() + &quot; &quot; + getTypeString(arrayAssignment.getType());</span>
<span class="fc" id="L230">        Expression[] indices = arrayAssignment.getIndices();</span>
<span class="fc" id="L231">        S_Expression[] idx = new S_Expression[indices.length + 1];</span>
<span class="fc" id="L232">        S_Expression[] checks = new S_Expression[indices.length];</span>
<span class="fc" id="L233">        idx[0] = new VarDef(arrayAssignment.getIdentifier().getName(), arrayAssignment.getType(),</span>
<span class="fc" id="L234">                    arrayAssignment.getDepth());</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (int i = 0; i &lt; indices.length; i++) {</span>
<span class="fc" id="L236">            indices[i].accept(this);</span>
<span class="fc" id="L237">            idx[i + 1] = new Constant(&quot;p&quot; + i);</span>
<span class="fc" id="L238">            checks[i] = new S_Expression(&quot;=&quot;, new Constant(&quot;p&quot; + i), tempExpr);</span>
        }
<span class="fc" id="L240">        arrayAssignment.getValue().accept(this);</span>
<span class="fc" id="L241">        VarDef varDef = new VarDef(arrayAssignment.getIdentifier().getName(),</span>
<span class="fc" id="L242">                arrayAssignment.getType(), arrayAssignment.getDepth());</span>
<span class="fc" id="L243">        currentProgram.replace(varDef, new Constant(var.toString()));</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        for (S_Expression fun : arrays) fun.replace(varDef, new Constant(var.toString()));</span>
<span class="fc" id="L245">        S_Expression defun = new S_Expression(&quot;define-fun&quot;, new Constant(variable),</span>
<span class="fc" id="L246">                   new S_Expression(&quot;ite&quot;, new S_Expression(&quot;and&quot;, checks),</span>
<span class="fc" id="L247">                       tempExpr, new S_Expression(&quot;&quot;, idx)));</span>
<span class="fc" id="L248">        arrays.add(defun);</span>
<span class="fc" id="L249">    }</span>

    @Override
    public void visit(ArithmeticExpression arithmeticExpression) {
<span class="fc" id="L253">        arithmeticExpression.getSubexpression1().accept(this);</span>
<span class="fc" id="L254">        ArithmeticOperator operator =</span>
<span class="fc" id="L255">                arithmeticExpression.getArithmeticOperator();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        int length = operator instanceof BinaryOperator ? 2 : 1;</span>
<span class="fc" id="L257">        S_Expression[] expressions = new S_Expression[length];</span>
<span class="fc" id="L258">        expressions[0] = tempExpr;</span>
<span class="fc" id="L259">        String op = operator.toString();</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (operator instanceof Division) {</span>
<span class="fc" id="L261">            op = &quot;div&quot;;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        } else if (operator instanceof Modulo) {</span>
<span class="fc" id="L263">            op = &quot;mod&quot;;</span>
        }
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (operator instanceof BinaryOperator) {</span>
<span class="fc" id="L266">            arithmeticExpression.getSubexpression2().accept(this);</span>
<span class="fc" id="L267">            expressions[1] = tempExpr;</span>
        }
<span class="fc" id="L269">        tempExpr = new S_Expression(op, expressions);</span>
<span class="fc" id="L270">    }</span>

    @Override
    public void visit(NumericLiteral number) {
<span class="fc" id="L274">        tempExpr = new Constant(number.toString());</span>
<span class="fc" id="L275">    }</span>

    @Override
    public void visit(LogicalExpression logicalExpression) {
<span class="fc" id="L279">        logicalExpression.getSubexpression1().accept(this);</span>
<span class="fc" id="L280">        LogicalOperator operator = logicalExpression.getLogicalOperator();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        int length = operator instanceof BinaryOperator ? 2 : 1;</span>
<span class="fc" id="L282">        S_Expression[] expressions = new S_Expression[length];</span>
<span class="fc" id="L283">        expressions[0] = tempExpr;</span>
<span class="fc" id="L284">        String op = operator.toString();</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (operator instanceof Negation) {</span>
<span class="fc" id="L286">            op = &quot;not&quot;;</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        } else if (operator instanceof Conjunction) {</span>
<span class="fc" id="L288">            op = &quot;and&quot;;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        } else if (operator instanceof Disjunction) {</span>
<span class="fc" id="L290">            op = &quot;or&quot;;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        } else if (operator instanceof Equal) {</span>
<span class="fc" id="L292">            op = &quot;=&quot;;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        } else if (operator instanceof NotEqual) {</span>
<span class="fc" id="L294">            op = &quot;distinct&quot;;</span>
        }
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (operator instanceof BinaryOperator) {</span>
<span class="fc" id="L297">            logicalExpression.getSubexpression2().accept(this);</span>
<span class="fc" id="L298">            expressions[1] = tempExpr;</span>
        }
<span class="fc" id="L300">        tempExpr = new S_Expression(op, expressions);</span>
<span class="fc" id="L301">    }</span>

    @Override
    public void visit(BooleanLiteral bool) {
<span class="fc" id="L305">        tempExpr = new Constant(bool.toString());</span>
<span class="fc" id="L306">    }</span>

    @Override
    public void visit(FunctionCall functionCall) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (&quot;length&quot;.equals(functionCall.getFunctionIdentifier().getName())) {</span>
<span class="fc" id="L311">            StringBuilder name = new StringBuilder(&quot;$length$&quot;);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (functionCall.getParameters()[0] instanceof ArrayRead) {</span>
<span class="fc" id="L313">                ArrayRead param = (ArrayRead) functionCall.getParameters()[0];</span>
<span class="fc" id="L314">                name.append(param.getVariable().getName()).append(&quot;$&quot;);</span>
<span class="fc" id="L315">                Expression[] indices = param.getIndices();</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">                for (int i = 0; i &lt; indices.length; i++) {</span>
<span class="fc" id="L317">                    name.append('*');</span>
                }
<span class="fc" id="L319">                tempExpr = new VarDef(name.toString(), new IntegerType(), 0);</span>
            } else {
<span class="fc" id="L321">                VariableRead param = (VariableRead) functionCall.getParameters()[0];</span>
<span class="fc" id="L322">                name.append(param.getVariable().getName()).append(&quot;$&quot;);</span>
<span class="fc" id="L323">                tempExpr = new VarDef(name.toString(), new IntegerType(), 0);</span>
            }
<span class="fc" id="L325">            return;</span>
        }
<span class="fc" id="L327">        Position position = functionCall.getPosition();</span>
<span class="fc" id="L328">        Function function = functionCall.getFunction();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        for (Ensure ensure : function.getEnsures()) {</span>
<span class="fc" id="L330">            ensure.accept(this);</span>
<span class="fc" id="L331">            replaceInFunctionResult(position, function);</span>
<span class="fc" id="L332">            currentProgram = new S_Expression(&quot;=&gt;&quot;, tempExpr, currentProgram);</span>
        }
<span class="fc bfc" id="L334" title="All 2 branches covered.">        for (Assumption assume : function.getAssumptions()) {</span>
<span class="fc" id="L335">            assume.accept(this);</span>
<span class="fc" id="L336">            replaceInFunctionAssume();</span>
<span class="fc" id="L337">            functionAssumes.add(tempExpr);</span>
        }
<span class="fc bfc" id="L339" title="All 2 branches covered.">        for (int i = 0; i &lt; function.getParameters().length; i++) {</span>
<span class="fc" id="L340">            functionCall.getParameters()[i].accept(this);</span>
<span class="fc" id="L341">            FunctionParameter param = function.getParameters()[i];</span>
<span class="fc" id="L342">            VarDef varDef = new VarDef(&quot;$param$&quot; + param.getName(), param.getType(), 0);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            for (int j = 0; j &lt; functionAssumes.size(); j++) {</span>
<span class="fc" id="L344">                S_Expression assume = functionAssumes.get(j);</span>
<span class="fc" id="L345">                assume.replace(varDef, tempExpr);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                if (assume.equals(varDef)) {</span>
<span class="fc" id="L347">                    functionAssumes.set(j, tempExpr);</span>
                }
            }
        }
<span class="fc" id="L351">        Statement[] statements = function.getFunctionBlock().getStatements();</span>
<span class="fc" id="L352">        (statements[statements.length - 1]).accept(this);</span>
<span class="fc" id="L353">        replaceInFunctionResult(position, function);</span>
<span class="fc" id="L354">    }</span>

    private void replaceInFunctionResult(Position position, Function function) {
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (VarDef varDef : tempExpr.getUndefinedVars()) {</span>
<span class="fc" id="L358">            String newName = &quot;res&lt;&quot; + function.getName() + &quot;&gt;@L&quot; + position.getLine()</span>
<span class="fc" id="L359">                    + 'C' + position.getColumn() + '$' + varDef.getIdent();</span>
<span class="fc" id="L360">            VarDef newVar = new VarDef(newName, varDef.getType(), 0);</span>
<span class="fc" id="L361">            tempExpr.replace(varDef, newVar);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (tempExpr.equals(varDef)) {</span>
<span class="fc" id="L363">                tempExpr = newVar;</span>
            }
        }
<span class="fc" id="L366">    }</span>

    private void replaceInFunctionAssume() {
<span class="fc bfc" id="L369" title="All 2 branches covered.">        for (VarDef varDef : tempExpr.getUndefinedVars()) {</span>
<span class="fc" id="L370">            String newName = &quot;$param$&quot; + varDef.getIdent();</span>
<span class="fc" id="L371">            VarDef newVar = new VarDef(newName, varDef.getType(), 0);</span>
<span class="fc" id="L372">            tempExpr.replace(varDef, newVar);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (tempExpr.equals(varDef)) {</span>
<span class="fc" id="L374">                tempExpr = newVar;</span>
            }
        }
<span class="fc" id="L377">    }</span>

    @Override
    public void visit(VariableRead variableRead) {
<span class="fc" id="L381">        String variableName = variableRead.toString();</span>
<span class="fc" id="L382">        tempExpr = new VarDef(variableName, variableRead.getType(),</span>
<span class="fc" id="L383">                variableRead.getDepth());</span>
<span class="fc" id="L384">    }</span>

    @Override
    public void visit(ArrayRead arrayRead) {
<span class="fc" id="L388">        Expression[] indices = arrayRead.getIndices();</span>
<span class="fc" id="L389">        S_Expression[] idx = new S_Expression[indices.length + 1];</span>
<span class="fc" id="L390">        idx[0] = new VarDef(arrayRead.getVariable().getName(), arrayRead.getType(),</span>
<span class="fc" id="L391">                    arrayRead.getDepth());</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        for (int i = 0; i &lt; indices.length; i++) {</span>
<span class="fc" id="L393">            indices[i].accept(this);</span>
<span class="fc" id="L394">            idx[i + 1] = tempExpr;</span>
        }
<span class="fc" id="L396">        tempExpr = new S_Expression(&quot;&quot;, idx);</span>
<span class="fc" id="L397">    }</span>

    @Override
    public void visit(Function function) {
<span class="fc" id="L401">        currentProgram = new Constant(&quot;true&quot;);</span>
<span class="fc" id="L402">        Ensure[] ensures = function.getEnsures();</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">        for (Ensure ensure : ensures) {</span>
<span class="fc" id="L404">            ensure.accept(this);</span>
<span class="fc" id="L405">            currentProgram = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L406">                    tempExpr, currentProgram);</span>
        }
<span class="fc" id="L408">        function.getFunctionBlock().accept(this);</span>
<span class="fc" id="L409">        LinkedList&lt;S_Expression&gt; program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L410">        program.add(currentProgram);</span>
<span class="fc" id="L411">        programs.add(program);</span>
<span class="fc" id="L412">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L413">                KindOfProgram.FunctionAssumeToRemainingProgram, function.getPosition()));</span>
<span class="fc" id="L414">        Assumption[] assumptions = function.getAssumptions();</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        for (Assumption assumption : assumptions) {</span>
<span class="fc" id="L416">            assumption.accept(this);</span>
<span class="fc" id="L417">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L418">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L420">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L421">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L422">                        program.getLast())));</span>
<span class="fc" id="L423">    }</span>

    @Override
    public void visit(Program program) {
<span class="fc" id="L427">        Function[] functions = program.getFunctions();</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        for (Function function : functions) {</span>
<span class="fc" id="L429">            function.accept(this);</span>
        }
<span class="fc" id="L431">        program.getMainFunction().accept(this);</span>
<span class="fc" id="L432">    }</span>

    @Override
    public void visit(Assignment assignment) {
<span class="fc" id="L436">        assignment.getValue().accept(this);</span>
<span class="fc" id="L437">        VarDef varDef = new VarDef(assignment.getIdentifier().toString(),</span>
<span class="fc" id="L438">                assignment.getType(), assignment.getDepth());</span>
<span class="fc" id="L439">        currentProgram.replace(varDef, tempExpr);</span>
<span class="fc" id="L440">    }</span>

    @Override
    public void visit(Assertion assertion) {
<span class="fc" id="L444">        assertion.getExpression().accept(this);</span>
<span class="fc" id="L445">        currentProgram = new S_Expression(&quot;and&quot;, tempExpr, currentProgram);</span>
<span class="fc" id="L446">    }</span>

    @Override
    public void visit(Assumption assumption) {
<span class="fc" id="L450">        assumption.getExpression().accept(this);</span>
<span class="fc" id="L451">    }</span>

    @Override
    public void visit(Axiom axiom) {
<span class="nc" id="L455">        axiom.getExpression().accept(this);</span>
<span class="nc" id="L456">    }</span>

    @Override
    public void visit(Ensure ensure) {
<span class="fc" id="L460">        ensure.getExpression().accept(this);</span>
<span class="fc" id="L461">    }</span>

    @Override
    public void visit(Invariant invariant) {
<span class="fc" id="L465">        invariant.getExpression().accept(this);</span>
<span class="fc" id="L466">    }</span>

    @Override
    public void visit(ReturnStatement returnStatement) {
<span class="fc" id="L470">        returnStatement.getReturnValue().accept(this);</span>
<span class="fc" id="L471">    }</span>

    @Override
    public void visit(VariableDeclaration varDec) {
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (varDec.getValue() != null) {</span>
<span class="fc" id="L476">            varDec.getValue().accept(this);</span>
        } else {
<span class="fc bfc" id="L478" title="All 2 branches covered.">            if (varDec.getType() instanceof BooleanType) {</span>
<span class="fc" id="L479">                tempExpr = new Constant(&quot;false&quot;);</span>
            } else {
<span class="fc" id="L481">                tempExpr = new Constant(&quot;0&quot;);</span>
            }
        }
<span class="fc" id="L484">        VarDef varDef = new VarDef(varDec.getName(), varDec.getType(), varDec.getDepth());</span>
<span class="fc" id="L485">        currentProgram.replace(varDef, tempExpr);</span>
<span class="fc" id="L486">    }</span>

    @Override
    public void visit(ArrayDeclaration arrDec) {
<span class="fc" id="L490">        String name = arrDec.getName();</span>
<span class="fc" id="L491">        int depth = arrDec.getDepth();</span>
<span class="fc" id="L492">        VarDef var = arrayVar(arrDec.getPosition(), name, arrDec.getType(), depth);</span>
<span class="fc" id="L493">        String variable = var.toString() + &quot; &quot; + getTypeString(arrDec.getType());</span>
<span class="fc" id="L494">        arrays.add(new S_Expression(&quot;define-fun&quot;, new Constant(variable), new Constant(&quot;0&quot;)));</span>
<span class="fc" id="L495">        tempExpr = new Constant(var.toString());</span>
<span class="fc" id="L496">        VarDef varDef = new VarDef(arrDec.getName(), arrDec.getType(), arrDec.getDepth());</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        for (S_Expression fun : arrays) fun.replace(varDef, tempExpr);</span>
<span class="fc" id="L498">        currentProgram.replace(varDef, tempExpr);</span>
<span class="fc" id="L499">        StringBuilder lname = new StringBuilder(&quot;$length$&quot;).append(name).append('$');</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        for (Expression idx : arrDec.getIndices()) {</span>
<span class="fc" id="L501">            idx.accept(this);</span>
<span class="fc" id="L502">            varDef = new VarDef(lname.toString(), new IntegerType(), 0);</span>
<span class="fc" id="L503">            currentProgram.replace(varDef, tempExpr);</span>
<span class="fc" id="L504">            lname.append('*');</span>
        }
<span class="fc" id="L506">    }</span>

    @Override
    public void visit(ExistsQuantifier existsQuantifier) {
<span class="fc" id="L510">        existsQuantifier.getSubexpression1().accept(this);</span>
<span class="fc" id="L511">        String name = existsQuantifier.getIdentifier().toString();</span>
<span class="fc" id="L512">        int depth = existsQuantifier.getDepth();</span>
<span class="fc" id="L513">        VarDef var = quantifierVar(existsQuantifier.getPosition(), name, depth);</span>
<span class="fc" id="L514">        String variable = &quot;((&quot; + var.toString() + &quot; Int))&quot;;</span>
<span class="fc" id="L515">        S_Expression saveTempExpr = tempExpr;</span>
<span class="fc" id="L516">        Range range = existsQuantifier.getRange();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (range != null) {</span>
<span class="fc" id="L518">            range.getLowerBound().accept(this);</span>
<span class="fc" id="L519">            saveTempExpr = new S_Expression(&quot;and&quot;, new S_Expression(</span>
<span class="fc" id="L520">                    &quot;&gt;=&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L521">            ), saveTempExpr);</span>
<span class="fc" id="L522">            range.getUpperBound().accept(this);</span>
<span class="fc" id="L523">            saveTempExpr = new S_Expression(&quot;and&quot;, new S_Expression(</span>
<span class="fc" id="L524">                    &quot;&lt;=&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L525">            ), saveTempExpr);</span>
        }
<span class="fc" id="L527">        saveTempExpr.replace(new VarDef(name, new IntegerType(), depth), var);</span>
<span class="fc" id="L528">        tempExpr = new S_Expression(&quot;exists&quot;, new Constant(variable), saveTempExpr);</span>
<span class="fc" id="L529">    }</span>

    @Override
    public void visit(ForAllQuantifier forAllQuantifier) {
<span class="fc" id="L533">        forAllQuantifier.getSubexpression1().accept(this);</span>
<span class="fc" id="L534">        String name = forAllQuantifier.getIdentifier().toString();</span>
<span class="fc" id="L535">        int depth = forAllQuantifier.getDepth();</span>
<span class="fc" id="L536">        VarDef var = quantifierVar(forAllQuantifier.getPosition(), name, depth);</span>
<span class="fc" id="L537">        String variable = &quot;((&quot; + var.toString() + &quot; Int))&quot;;</span>
<span class="fc" id="L538">        S_Expression saveTempExpr = tempExpr;</span>
<span class="fc" id="L539">        Range range = forAllQuantifier.getRange();</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (range != null) {</span>
<span class="fc" id="L541">            range.getLowerBound().accept(this);</span>
<span class="fc" id="L542">            saveTempExpr = new S_Expression(&quot;or&quot;, new S_Expression(</span>
<span class="fc" id="L543">                    &quot;&lt;&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L544">            ), saveTempExpr);</span>
<span class="fc" id="L545">            range.getUpperBound().accept(this);</span>
<span class="fc" id="L546">            saveTempExpr = new S_Expression(&quot;or&quot;, new S_Expression(</span>
<span class="fc" id="L547">                    &quot;&gt;&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L548">            ), saveTempExpr);</span>
        }
<span class="fc" id="L550">        saveTempExpr.replace(new VarDef(name, new IntegerType(), depth), var);</span>
<span class="fc" id="L551">        tempExpr = new S_Expression(&quot;forall&quot;, new Constant(variable), saveTempExpr);</span>
<span class="fc" id="L552">    }</span>

    private static VarDef quantifierVar(Position position, String name, int depth) {
<span class="fc" id="L555">        String varDefName = &quot;qvar&lt;&quot; + name + &quot;&gt;@L&quot; + position.getLine()</span>
<span class="fc" id="L556">                    + 'C' + position.getColumn();</span>
<span class="fc" id="L557">        return new VarDef(varDefName, new IntegerType(), depth);</span>
    }

    @Override
    public void visit(StatementBlock statementBlock) {
<span class="fc" id="L562">        Statement[] statements = statementBlock.getStatements();</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        for (int i = statements.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L564">            functionAssumes = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L565">            statements[i].accept(this);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">            for (S_Expression assume : functionAssumes) {</span>
<span class="fc" id="L567">                currentProgram = new S_Expression(&quot;and&quot;, assume, currentProgram);</span>
            }
        }
<span class="fc" id="L570">    }</span>

    private VarDef arrayVar(Position position, String name, Type t, int depth) {
<span class="fc" id="L573">        String varDefName = &quot;$array@&quot; + 'l' + position.getLine()</span>
<span class="fc" id="L574">                    + 'c' + position.getColumn() + '$' + name;</span>
<span class="fc" id="L575">        return new VarDef(varDefName, t, depth);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.6.201201232323</span>Merged (08.03.2012 02:43:23)</div></body></html>