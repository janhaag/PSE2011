<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>SMTLibTranslator.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Coverage (07.03.2012 11:56:57)</a> &gt; <a href="../../index.html" class="el_group">pse</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.html" class="el_package">verifier.smtlib</a> &gt; <span class="el_source">SMTLibTranslator.java</span></div><h1>SMTLibTranslator.java</h1><pre class="source lang-java linenums">package verifier.smtlib;

import ast.*;
import misc.Pair;
import verifier.KindOfProgram;

import java.util.*;

/**
 * This class translates a program given as AST into the smtlib format that can
 * be given to certain verifiers.
 */
<span class="fc" id="L13">public class SMTLibTranslator implements ASTVisitor {</span>
    /**
     * list of descriptions for the programs
     */
    private LinkedList&lt;Pair&lt;KindOfProgram, Position&gt;&gt; descriptions;
    /**
     * temporarily saves the list of all programs,
     * i.e. a list of all contracts to be verified
     */
    private ArrayList&lt;LinkedList&lt;S_Expression&gt;&gt; programs;
    /**
     * temporarily saves the replacement that must be made in
     * the upper scope after the current scope is evaluated
     */
    //private Stack&lt;HashMap&lt;VarDef, S_Expression&gt;&gt; upScopeReplacements;
    /**
     * temporarily saves the expression of the upper scope that will
     * be integrated in the program at a later time
     */
    //private Stack&lt;S_Expression&gt; upScopeExpr;
    /**
     * Maps Array Names to tags
     */
    private HashMap&lt;String, Integer&gt; arrays;
    /**
     * temporarily saves the current expression
     */
    private S_Expression tempExpr;
    /**
     * temporarily saves the number of the current program
     */
    private S_Expression currentProgram;
    /**
     * temporarily saves whether changes to tempExpression should be saved
     */
    //private boolean change;
    /**
     * temporarily saves whether a function call is evaluated
     */
    //private boolean isFunctionCall;
    /**
     * temporarily saves the function called in the current statement
     */
    //private ArrayList&lt;FunctionCall&gt; functionsCalled;
    /**
     * temporarily saves the number of the function call
     * in the program
     */
    private int noOfFuncCall;
    /**
     * temporarily saves the number of the function call
     * in the program
     */
    private int noOfQuantifier;

    /**
     * Translates the given AST into a formula
     * and returns a WPProgram that contains all contracts to be verified.
     *
     * @param ast given AST
     * @return WPProgram of all contracts to be verified
     */
    public WPProgram getWPTree(ASTRoot ast) {
<span class="fc" id="L76">        programs = new ArrayList&lt;LinkedList&lt;S_Expression&gt;&gt;();</span>
<span class="fc" id="L77">        descriptions = new LinkedList&lt;Pair&lt;KindOfProgram, Position&gt;&gt;();</span>
<span class="fc" id="L78">        arrays = new HashMap&lt;String, Integer&gt;();</span>
<span class="fc" id="L79">        ast.accept(this);</span>
<span class="fc" id="L80">        LinkedList&lt;S_Expression&gt; result = prepareFinalProgram(programs);</span>
<span class="fc" id="L81">        int size = result.size();</span>
<span class="fc" id="L82">        return new WPProgram(result.toArray(new S_Expression[size]));</span>
    }

    /**
     * Returns a list of program descriptions.
     * @return list of program descriptions
     */
    public LinkedList&lt;Pair&lt;KindOfProgram, Position&gt;&gt; getDescriptions() {
<span class="fc" id="L90">        return descriptions;</span>
    }

    /**
     * Prepares the final program after the most translations.
     * @param programs programs to be prepared to form the final program
     * @return final program
     */
    private static LinkedList&lt;S_Expression&gt; prepareFinalProgram(ArrayList&lt;LinkedList&lt;S_Expression&gt;&gt; programs) {
<span class="fc" id="L99">        ListIterator&lt;LinkedList&lt;S_Expression&gt;&gt; i = programs.listIterator();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        while(i.hasNext()) {</span>
<span class="fc" id="L101">           createBlock(i.next());</span>
        }
<span class="fc" id="L103">        i = programs.listIterator();</span>
        ListIterator&lt;S_Expression&gt; j;
<span class="fc" id="L105">        LinkedList&lt;S_Expression&gt; result = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        while(i.hasNext()) {</span>
<span class="fc" id="L107">            j = i.next().listIterator();</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            while(j.hasNext()) {</span>
<span class="fc" id="L109">                result.add(j.next());</span>
            }
        }
<span class="fc" id="L112">        result.addFirst(new S_Expression(&quot;set-logic&quot;,</span>
<span class="fc" id="L113">                new Constant(&quot;AUFNIRA&quot;)));</span>
<span class="fc" id="L114">        return result;</span>
    }

    /**
     * Creates a block, i.e. a single contract to be verified.
     * @param program program to be formed to the final block
     */
    private static void createBlock(LinkedList&lt;S_Expression&gt; program) {
<span class="fc" id="L122">        LinkedList&lt;VarDef&gt; vars = program.getLast().getUndefinedVars();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        for (VarDef var : vars) {</span>
<span class="fc" id="L124">            program.addFirst(new S_Expression(&quot;declare-fun&quot;,</span>
<span class="fc" id="L125">                    new Constant(var.getFullRepresentation())));</span>
        }
<span class="fc" id="L127">        program.addFirst(new Constant(&quot;(push)&quot;));</span>
<span class="fc" id="L128">        program.addLast(new Constant(&quot;(check-sat)&quot;));</span>
<span class="fc" id="L129">        program.addLast(new Constant(&quot;(get-model)&quot;));</span>
<span class="fc" id="L130">        program.addLast(new Constant(&quot;(pop)&quot;));</span>
<span class="fc" id="L131">    }</span>

    /**
     * Replaces a variable in a given map with a new expression.
     * @param map specified map for replacement
     * @param varDef variable to be replaced
     * @param newExpr new expression to replace varDef
     */
    /*private static void replaceInAssignments(Map&lt;VarDef, S_Expression&gt; map,
                                     VarDef varDef, S_Expression newExpr) {
        for (Map.Entry&lt;VarDef, S_Expression&gt; oldEntry : map.entrySet()) {
            oldEntry.getValue().replace(varDef,
                    newExpr.deepCopy());
        }
        if (!map.containsKey(varDef)) {
            map.put(varDef, newExpr.deepCopy());
        }
    }*/

    /**
     * Returns the string representation of the given type
     * @param type given type
     * @return string representation of the given type
     */
    public static String getTypeString(Type type) {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (type instanceof IntegerType) return &quot;Int&quot;;</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        else if (type instanceof BooleanType) return &quot;Bool&quot;;</span>
        else {
<span class="nc" id="L159">            Type t = type;</span>
<span class="nc" id="L160">            StringBuilder result = new StringBuilder().append(&quot;(&quot;);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            while (t instanceof ArrayType) {</span>
<span class="nc" id="L162">                t = ((ArrayType) t).getType();</span>
<span class="nc" id="L163">                result.append(&quot;Int &quot;);</span>
            }
<span class="nc" id="L165">            result.append(getTypeString(t)).append(&quot;)&quot;);</span>
<span class="nc" id="L166">            return result.toString();</span>
        }
    }

    /**
     * Handles the replacements after a program
     * is separated at a loop or function call
     */
    /*private void prepareEndedLoop(LinkedList&lt;S_Expression&gt; program) {
        while (upScopeReplacements.size() &gt; 1) {
            S_Expression upperExpr = upScopeExpr.pop();
            HashMap&lt;VarDef, S_Expression&gt; replacements =
                    upScopeReplacements.pop();
            for (Map.Entry&lt;VarDef, S_Expression&gt; entry :
                    replacements.entrySet()) {
                upperExpr.replace(entry.getKey(), entry.getValue().deepCopy());
                if (entry.getKey().getDepth() &lt; upScopeReplacements.size()) {
                    upScopeReplacements.lastElement().put(entry.getKey(),
                            entry.getValue().deepCopy());
                }
            }
            program.set(program.size() - 1, new S_Expression(&quot;and&quot;,
                    upperExpr, program.getLast()));
        }
    }*/

    @Override
    public void visit(Conditional conditional) {
        /*upScopeExpr.push(tempExpr);
        Stack&lt;S_Expression&gt; tempExprStack = new Stack&lt;S_Expression&gt;();
        for (S_Expression expression : upScopeExpr) {
            tempExprStack.push(expression.deepCopy());
        }
        upScopeReplacements.push(new HashMap&lt;VarDef, S_Expression&gt;());
        Stack&lt;HashMap&lt;VarDef, S_Expression&gt;&gt; tempReplacements =
                new Stack&lt;HashMap&lt;VarDef, S_Expression&gt;&gt;();
        for (HashMap&lt;VarDef, S_Expression&gt; replacements : upScopeReplacements) {
            tempReplacements.push(new HashMap&lt;VarDef, S_Expression&gt;());
            for (Map.Entry&lt;VarDef, S_Expression&gt; entry : replacements.entrySet()) {
                tempReplacements.lastElement().put(entry.getKey(),
                        entry.getValue().deepCopy());
            }
        }
        conditional.getCondition().accept(this);
        S_Expression condition = tempExpr;
        tempExpr = new Constant(&quot;true&quot;);
        conditional.getTrueConditionBody().accept(this);
        S_Expression result = tempExpr;
        HashMap&lt;VarDef, S_Expression&gt; replacements = upScopeReplacements.pop();
        Set&lt;Map.Entry&lt;VarDef, S_Expression&gt;&gt; entries = replacements.entrySet();
        tempExpr = upScopeExpr.lastElement().deepCopy();
        for (Map.Entry&lt;VarDef, S_Expression&gt; entry : entries) {
            tempExpr.replace(entry.getKey(), entry.getValue());
        }
        tempExpr = new S_Expression(&quot;and&quot;, result.deepCopy(), tempExpr.deepCopy());
        S_Expression trueBranch = new S_Expression(&quot;and&quot;,
                condition.deepCopy(), tempExpr);
        upScopeExpr = tempExprStack;
        upScopeReplacements = tempReplacements;
        tempExpr = new Constant(&quot;true&quot;);
        if (conditional.getFalseConditionBody() != null) {
            conditional.getFalseConditionBody().accept(this);
        }
        entries = upScopeReplacements.pop().entrySet();
        tempExpr = upScopeExpr.pop().deepCopy();
        for (Map.Entry&lt;VarDef, S_Expression&gt; entry : entries) {
            tempExpr.replace(entry.getKey(), entry.getValue());
            if (replacements.containsKey(entry.getKey())) {
                replaceInAssignments(upScopeReplacements.lastElement(),
                        entry.getKey(),
                        new S_Expression(&quot;ite&quot;, new S_Expression(&quot;not&quot;,
                                condition.deepCopy()),
                                entry.getValue(),
                                replacements.get(entry.getKey())));
                replacements.remove(entry.getKey());
            } else {
                replaceInAssignments(upScopeReplacements.lastElement(),
                        entry.getKey(),
                        new S_Expression(&quot;ite&quot;, condition.deepCopy(),
                                entry.getKey().deepCopy(),
                                entry.getValue()));
            }
        }
        entries = replacements.entrySet();
        for (Map.Entry&lt;VarDef, S_Expression&gt; entry : entries) {
            replaceInAssignments(upScopeReplacements.lastElement(),
                    entry.getKey(),
                    new S_Expression(&quot;ite&quot;, condition.deepCopy(),
                            replacements.get(entry.getKey()),
                            entry.getKey().deepCopy()));
        }
        S_Expression falseBranch = new S_Expression(&quot;and&quot;,
                new S_Expression(&quot;not&quot;,
                        condition), tempExpr);
        tempExpr = new S_Expression(&quot;or&quot;,
                trueBranch, falseBranch);
        change = true;
        functionsCalled = new ArrayList&lt;FunctionCall&gt;();*/
<span class="fc" id="L264">        S_Expression saveProgram = currentProgram;</span>
<span class="fc" id="L265">        conditional.getCondition().accept(this);</span>
<span class="fc" id="L266">        S_Expression condition = tempExpr;</span>
<span class="fc" id="L267">        currentProgram = saveProgram.deepCopy();</span>
<span class="fc" id="L268">        conditional.getTrueConditionBody().accept(this);</span>
<span class="fc" id="L269">        S_Expression trueBranch = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L270">                condition.deepCopy(), currentProgram);</span>
<span class="fc" id="L271">        currentProgram = saveProgram.deepCopy();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (conditional.getFalseConditionBody() != null) {</span>
<span class="fc" id="L273">            conditional.getFalseConditionBody().accept(this);</span>
        }
<span class="fc" id="L275">        S_Expression falseBranch = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L276">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L277">                        condition), currentProgram);</span>
<span class="fc" id="L278">        currentProgram = new S_Expression(&quot;or&quot;,</span>
<span class="fc" id="L279">                trueBranch, falseBranch);</span>
        //change = true;
        //functionsCalled = new ArrayList&lt;FunctionCall&gt;();
<span class="fc" id="L282">    }</span>

    @Override
    public void visit(Loop loop) {
<span class="fc" id="L286">        Ensure[] ensures = loop.getPostconditions();</span>
        //int depth = upScopeReplacements.size();
        //ensures=&gt;rest
<span class="fc" id="L289">        LinkedList&lt;S_Expression&gt; program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L290">        program.add(currentProgram);</span>
<span class="fc" id="L291">        programs.add(program);</span>
<span class="fc" id="L292">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L293">                KindOfProgram.WhileEnsureToRemainingProgram, loop.getPosition()));</span>
        //prepareEndedLoop(program);
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (Ensure ensure : ensures) {</span>
<span class="fc" id="L296">            ensure.accept(this);</span>
<span class="fc" id="L297">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L298">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L300">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L301">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L302">                        program.getLast())));</span>
        //invariants &amp; !condition =&gt; ensures
<span class="fc" id="L304">        program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L305">        programs.add(program);</span>
<span class="fc" id="L306">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L307">                KindOfProgram.InvariantAndNotConditionToWhileEnsure, loop.getPosition()));</span>
<span class="fc" id="L308">        program.add(new Constant(&quot;true&quot;));</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        for (Ensure ensure : ensures) {</span>
<span class="fc" id="L310">            ensure.accept(this);</span>
<span class="fc" id="L311">            program.set(program.size() - 1, new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L312">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L314">        Invariant[] invariants = loop.getInvariants();</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L316">            invariant.accept(this);</span>
<span class="fc" id="L317">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L318">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L320">        loop.getCondition().accept(this);</span>
<span class="fc" id="L321">        program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L322">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L323">                        tempExpr), program.getLast()));</span>
<span class="fc" id="L324">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L325">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L326">                        program.getLast())));</span>
        //invariants &amp; condition =&gt; invariant
        /*upScopeReplacements = new Stack&lt;HashMap&lt;VarDef, S_Expression&gt;&gt;();
        upScopeExpr = new Stack&lt;S_Expression&gt;();
        for (int i = 0; i &lt; depth; i++) {
            upScopeReplacements.add(new HashMap&lt;VarDef, S_Expression&gt;());
            upScopeExpr.add(new Constant(&quot;true&quot;));
        }*/
<span class="fc" id="L334">        currentProgram = new Constant(&quot;true&quot;);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L336">            invariant.accept(this);</span>
<span class="fc" id="L337">            currentProgram =  new S_Expression(&quot;and&quot;, tempExpr, currentProgram);</span>
        }
<span class="fc" id="L339">        loop.getLoopBody().accept(this);</span>
<span class="fc" id="L340">        program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L341">        programs.add(program);</span>
<span class="fc" id="L342">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L343">                KindOfProgram.InvariantAndConditionToInvariant, loop.getPosition()));</span>
<span class="fc" id="L344">        program.add(currentProgram);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L346">            invariant.accept(this);</span>
<span class="fc" id="L347">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L348">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L350">        loop.getCondition().accept(this);</span>
<span class="fc" id="L351">        program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L352">                tempExpr, program.getLast()));</span>
<span class="fc" id="L353">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L354">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L355">                        program.getLast())));</span>
        //pre=&gt;invariants
        /*upScopeReplacements = new Stack&lt;HashMap&lt;VarDef, S_Expression&gt;&gt;();
        upScopeExpr = new Stack&lt;S_Expression&gt;();
        for (int i = 0; i &lt; depth; i++) {
            upScopeReplacements.add(new HashMap&lt;VarDef, S_Expression&gt;());
            upScopeExpr.add(new Constant(&quot;true&quot;));
        }*/
<span class="fc" id="L363">        currentProgram = new Constant(&quot;true&quot;);</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (Invariant invariant : invariants) {</span>
<span class="fc" id="L365">            invariant.accept(this);</span>
<span class="fc" id="L366">            currentProgram = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L367">                    tempExpr, currentProgram);</span>
        }
        //functionsCalled = new ArrayList&lt;FunctionCall&gt;();
<span class="fc" id="L370">    }</span>

    @Override
    public void visit(ArrayAssignment arrayAssignment) {
<span class="nc" id="L374">        String oldName = getMangledArrayName(arrayAssignment.getIdentifier().getName(), false);</span>
<span class="nc" id="L375">        String name = getMangledArrayName(arrayAssignment.getIdentifier().getName(), true);</span>
<span class="nc" id="L376">        tempExpr = new S_Expression(&quot;define-function&quot;, new Constant(name),</span>
<span class="nc" id="L377">                new Constant(getTypeString(arrayAssignment.getType())),</span>
<span class="nc" id="L378">                new S_Expression(&quot;ite&quot;));</span>
<span class="nc" id="L379">    }</span>

    @Override
    public void visit(ArithmeticExpression arithmeticExpression) {
<span class="fc" id="L383">        arithmeticExpression.getSubexpression1().accept(this);</span>
<span class="fc" id="L384">        ArithmeticOperator operator =</span>
<span class="fc" id="L385">                arithmeticExpression.getArithmeticOperator();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        int length = operator instanceof BinaryOperator ? 2 : 1;</span>
<span class="fc" id="L387">        S_Expression[] expressions = new S_Expression[length];</span>
<span class="fc" id="L388">        expressions[0] = tempExpr;</span>
<span class="fc" id="L389">        String op = operator.toString();</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (operator instanceof Division) {</span>
<span class="fc" id="L391">            op = &quot;div&quot;;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        } else if (operator instanceof Modulo) {</span>
<span class="fc" id="L393">            op = &quot;mod&quot;;</span>
        }
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (operator instanceof BinaryOperator) {</span>
<span class="fc" id="L396">            arithmeticExpression.getSubexpression2().accept(this);</span>
<span class="fc" id="L397">            expressions[1] = tempExpr;</span>
        }
<span class="fc" id="L399">        tempExpr = new S_Expression(op, expressions);</span>
<span class="fc" id="L400">    }</span>

    @Override
    public void visit(NumericLiteral number) {
<span class="fc" id="L404">        tempExpr = new Constant(number.toString());</span>
<span class="fc" id="L405">    }</span>

    @Override
    public void visit(LogicalExpression logicalExpression) {
<span class="fc" id="L409">        logicalExpression.getSubexpression1().accept(this);</span>
<span class="fc" id="L410">        LogicalOperator operator = logicalExpression.getLogicalOperator();</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        int length = operator instanceof BinaryOperator ? 2 : 1;</span>
<span class="fc" id="L412">        S_Expression[] expressions = new S_Expression[length];</span>
<span class="fc" id="L413">        expressions[0] = tempExpr;</span>
<span class="fc" id="L414">        String op = operator.toString();</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (operator instanceof Negation) {</span>
<span class="fc" id="L416">            op = &quot;not&quot;;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        } else if (operator instanceof Conjunction) {</span>
<span class="fc" id="L418">            op = &quot;and&quot;;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        } else if (operator instanceof Disjunction) {</span>
<span class="fc" id="L420">            op = &quot;or&quot;;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        } else if (operator instanceof Equal) {</span>
<span class="fc" id="L422">            op = &quot;=&quot;;</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">        } else if (operator instanceof NotEqual) {</span>
<span class="fc" id="L424">            op = &quot;distinct&quot;;</span>
        }
<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (operator instanceof BinaryOperator) {</span>
<span class="fc" id="L427">            logicalExpression.getSubexpression2().accept(this);</span>
<span class="fc" id="L428">            expressions[1] = tempExpr;</span>
        }
<span class="fc" id="L430">        tempExpr = new S_Expression(op, expressions);</span>
<span class="fc" id="L431">    }</span>

    @Override
    public void visit(BooleanLiteral bool) {
<span class="fc" id="L435">        tempExpr = new Constant(bool.toString());</span>
<span class="fc" id="L436">    }</span>

    @Override
    public void visit(FunctionCall functionCall) {
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (&quot;length&quot;.equals(functionCall.getFunctionIdentifier().getName())) {</span>
<span class="nc" id="L441">            tempExpr = new Constant(&quot;5&quot;);</span>
<span class="nc" id="L442">            return;</span>
        }
<span class="fc" id="L444">        noOfFuncCall += 1;</span>
<span class="fc" id="L445">        Position position = functionCall.getPosition();</span>
<span class="fc" id="L446">        Function function = functionCall.getFunction();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (Ensure ensure : function.getEnsures()) {</span>
<span class="fc" id="L448">            ensure.accept(this);</span>
<span class="fc" id="L449">            replaceInFunctionResult(position, function);</span>
<span class="fc" id="L450">            currentProgram = new S_Expression(&quot;=&gt;&quot;, tempExpr, currentProgram);</span>
        }
<span class="fc bfc" id="L452" title="All 2 branches covered.">        for (Assumption assume : function.getAssumptions()) {</span>
<span class="fc" id="L453">            assume.accept(this);</span>
<span class="fc" id="L454">            replaceInFunctionAssume();</span>
<span class="fc" id="L455">            currentProgram = new S_Expression(&quot;and&quot;, tempExpr, currentProgram);</span>
        }
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (int i = 0; i &lt; function.getParameters().length; i++) {</span>
<span class="fc" id="L458">            functionCall.getParameters()[i].accept(this);</span>
<span class="fc" id="L459">            FunctionParameter param = function.getParameters()[i];</span>
<span class="fc" id="L460">            VarDef varDef = new VarDef(&quot;$param$&quot; + param.getName(), param.getType(), 0);</span>
<span class="fc" id="L461">            currentProgram.replace(varDef, tempExpr);</span>
        }
<span class="fc" id="L463">        Statement[] statements = function.getFunctionBlock().getStatements();</span>
<span class="fc" id="L464">        (statements[statements.length - 1]).accept(this);</span>
<span class="fc" id="L465">        replaceInFunctionResult(position, function);           </span>
<span class="fc" id="L466">    }</span>

    private void replaceInFunctionResult(Position position, Function function) {
<span class="fc bfc" id="L469" title="All 2 branches covered.">        for (VarDef varDef : tempExpr.getUndefinedVars()) {</span>
<span class="fc" id="L470">            String newName = &quot;$res&quot; + noOfFuncCall + 'l' + position.getLine()</span>
<span class="fc" id="L471">                    + 'c' + position.getColumn() + '$' + function.getName()</span>
<span class="fc" id="L472">                    + '$' + varDef.getIdent();</span>
<span class="fc" id="L473">            VarDef newVar = new VarDef(newName, varDef.getType(), 0);</span>
<span class="fc" id="L474">            tempExpr.replace(varDef, newVar);</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">            if (tempExpr.equals(varDef)) {</span>
<span class="fc" id="L476">                tempExpr = newVar;</span>
            }
        }
<span class="fc" id="L479">    }</span>
    
    private void replaceInFunctionAssume() {
<span class="fc bfc" id="L482" title="All 2 branches covered.">        for (VarDef varDef : tempExpr.getUndefinedVars()) {</span>
<span class="fc" id="L483">            String newName = &quot;$param$&quot; + varDef.getIdent();</span>
<span class="fc" id="L484">            VarDef newVar = new VarDef(newName, varDef.getType(), 0);</span>
<span class="fc" id="L485">            tempExpr.replace(varDef, newVar);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (tempExpr.equals(varDef)) {</span>
<span class="fc" id="L487">                tempExpr = newVar;</span>
            }
        }
<span class="fc" id="L490">    }</span>

    /**
     * Handles the work needed after a function call.
     */
   /* private void afterFunctionCall(FunctionCall functionCall) {
        S_Expression saveTempExpr = tempExpr;
        Ensure[] ensures = functionCall.getFunction().getEnsures();
        //ensures=&gt;rest
        LinkedList&lt;S_Expression&gt; program = programs.get(programs.size() - 1);
        for (Ensure ensure : ensures) {
            isFunctionCall = true;
            ensure.accept(this);
            isFunctionCall = false;
            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,
                    tempExpr, program.getLast()));
        }
        //pre=&gt;assumptions
        noOfFuncCall = 0;
        for (Assumption assumption : functionCall.getFunction().getAssumptions()) {
            assumption.accept(this);
            saveTempExpr = new S_Expression(&quot;and&quot;,
                    tempExpr, saveTempExpr);
        }
        FunctionParameter[] parameters = functionCall.getFunction().getParameters();
        for (int i = 0; i &lt; functionCall.getParameters().length; i++) {
            functionCall.getParameters()[i].accept(this);
            VarDef varDef = new VarDef(parameters[i].getName(),
                    parameters[i].getType(), 0);
            saveTempExpr.replace(varDef, tempExpr);
        }
        tempExpr = saveTempExpr;
    } */

    @Override
    public void visit(VariableRead variableRead) {
<span class="fc" id="L526">        String variableName = variableRead.toString();</span>
        /*if (isFunctionCall) {
            variableName = variableName + '$' + Integer.toString(noOfFuncCall);
        }*/
<span class="fc" id="L530">        tempExpr = new VarDef(variableName, variableRead.getType(),</span>
<span class="fc" id="L531">                variableRead.getDepth());</span>
<span class="fc" id="L532">    }</span>

    @Override
    public void visit(ArrayRead arrayRead) {
<span class="nc" id="L536">        String name = getMangledArrayName(arrayRead.getVariable().getName(), true);</span>
<span class="nc" id="L537">        Expression[] indices = arrayRead.getIndices();</span>
<span class="nc" id="L538">        S_Expression[] idx = new S_Expression[indices.length];</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">        for (int i = 0; i &lt; indices.length; i++) {</span>
<span class="nc" id="L540">            indices[i].accept(this);</span>
<span class="nc" id="L541">            idx[i] = tempExpr;</span>
        }
<span class="nc" id="L543">        tempExpr = new S_Expression (name, new S_Expression(&quot;&quot;, idx));</span>
<span class="nc" id="L544">    }</span>

    @Override
    public void visit(Function function) {
        /*upScopeReplacements = new Stack&lt;HashMap&lt;VarDef, S_Expression&gt;&gt;();
        upScopeReplacements.push(new HashMap&lt;VarDef, S_Expression&gt;());
        upScopeExpr = new Stack&lt;S_Expression&gt;();*/
<span class="fc" id="L551">        currentProgram = new Constant(&quot;true&quot;);</span>
<span class="fc" id="L552">        Ensure[] ensures = function.getEnsures();</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (Ensure ensure : ensures) {</span>
<span class="fc" id="L554">            ensure.accept(this);</span>
<span class="fc" id="L555">            currentProgram = new S_Expression(&quot;and&quot;,</span>
<span class="fc" id="L556">                    tempExpr, currentProgram);</span>
        }
<span class="fc" id="L558">        function.getFunctionBlock().accept(this);</span>
<span class="fc" id="L559">        LinkedList&lt;S_Expression&gt; program = new LinkedList&lt;S_Expression&gt;();</span>
<span class="fc" id="L560">        program.add(currentProgram);</span>
<span class="fc" id="L561">        programs.add(program);</span>
<span class="fc" id="L562">        descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(</span>
<span class="fc" id="L563">                KindOfProgram.FunctionAssumeToRemainingProgram, function.getPosition()));</span>
<span class="fc" id="L564">        Assumption[] assumptions = function.getAssumptions();</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">        for (Assumption assumption : assumptions) {</span>
<span class="fc" id="L566">            assumption.accept(this);</span>
<span class="fc" id="L567">            program.set(program.size() - 1, new S_Expression(&quot;=&gt;&quot;,</span>
<span class="fc" id="L568">                    tempExpr, program.getLast()));</span>
        }
<span class="fc" id="L570">        program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,</span>
<span class="fc" id="L571">                new S_Expression(&quot;not&quot;,</span>
<span class="fc" id="L572">                        program.getLast())));</span>
<span class="fc" id="L573">    }</span>

    @Override
    public void visit(Program program) {
<span class="fc" id="L577">        Function[] functions = program.getFunctions();</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        for (Function function : functions) {</span>
<span class="fc" id="L579">            function.accept(this);</span>
        }
<span class="fc" id="L581">        program.getMainFunction().accept(this);</span>
<span class="fc" id="L582">    }</span>

    @Override
    public void visit(Assignment assignment) {
<span class="fc" id="L586">        assignment.getValue().accept(this);</span>
<span class="fc" id="L587">        VarDef varDef = new VarDef(assignment.getIdentifier().toString(),</span>
<span class="fc" id="L588">                assignment.getType(), assignment.getDepth());</span>
<span class="fc" id="L589">        currentProgram.replace(varDef, tempExpr);</span>
        //replaceInAssignments(upScopeReplacements.lastElement(), varDef, tempExpr);
<span class="fc" id="L591">    }</span>

    @Override
    public void visit(Assertion assertion) {
<span class="fc" id="L595">        assertion.getExpression().accept(this);</span>
<span class="fc" id="L596">        currentProgram = new S_Expression(&quot;and&quot;, tempExpr, currentProgram);</span>
<span class="fc" id="L597">    }</span>

    @Override
    public void visit(Assumption assumption) {
<span class="fc" id="L601">        assumption.getExpression().accept(this);</span>
<span class="fc" id="L602">    }</span>

    @Override
    public void visit(Axiom axiom) {
<span class="nc" id="L606">        axiom.getExpression().accept(this);</span>
<span class="nc" id="L607">    }</span>

    @Override
    public void visit(Ensure ensure) {
<span class="fc" id="L611">        ensure.getExpression().accept(this);</span>
<span class="fc" id="L612">    }</span>

    @Override
    public void visit(Invariant invariant) {
<span class="fc" id="L616">        invariant.getExpression().accept(this);</span>
<span class="fc" id="L617">    }</span>

    @Override
    public void visit(ReturnStatement returnStatement) {
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (noOfFuncCall &gt; 0) {</span>
<span class="fc" id="L622">            returnStatement.getReturnValue().accept(this);</span>
        }
<span class="fc" id="L624">    }</span>

    @Override
    public void visit(VariableDeclaration varDec) {
<span class="fc bfc" id="L628" title="All 2 branches covered.">        if (varDec.getValue() != null) {</span>
<span class="fc" id="L629">            varDec.getValue().accept(this);</span>
        } else {
<span class="fc bfc" id="L631" title="All 2 branches covered.">            if (varDec.getType() instanceof BooleanType) {</span>
<span class="fc" id="L632">                tempExpr = new Constant(&quot;false&quot;);</span>
            } else {
<span class="fc" id="L634">                tempExpr = new Constant(&quot;0&quot;);</span>
            }
        }
<span class="fc" id="L637">        VarDef varDef = new VarDef(varDec.getName(), varDec.getType(), varDec.getDepth());</span>
<span class="fc" id="L638">        currentProgram.replace(varDef, tempExpr);</span>
        //replaceInAssignments(upScopeReplacements.lastElement(),
        //        varDef, tempExpr);
        //upScopeReplacements.lastElement().remove(varDef);
<span class="fc" id="L642">    }</span>

    @Override
    public void visit(ArrayDeclaration arrDec) {
<span class="nc" id="L646">        String name = getMangledArrayName(arrDec.getName(), true);</span>
<span class="nc" id="L647">        VarDef varDef = new VarDef(name, arrDec.getType(), arrDec.getDepth());</span>
<span class="nc" id="L648">        currentProgram.replace(varDef, tempExpr);</span>
        //replaceInAssignments(upScopeReplacements.lastElement(),
        //        varDef, tempExpr);
        //upScopeReplacements.lastElement().remove(varDef);
<span class="nc" id="L652">    }</span>

    @Override
    public void visit(ExistsQuantifier existsQuantifier) {
<span class="fc" id="L656">        existsQuantifier.getSubexpression1().accept(this);</span>
<span class="fc" id="L657">        noOfQuantifier += 1;</span>
<span class="fc" id="L658">        String name = existsQuantifier.getIdentifier().toString();</span>
<span class="fc" id="L659">        int depth = existsQuantifier.getDepth();</span>
<span class="fc" id="L660">        VarDef var = quantifierVar(existsQuantifier.getPosition(), name, depth);</span>
<span class="fc" id="L661">        String variable = &quot;((&quot; + var.toString() + &quot; Int))&quot;;</span>
<span class="fc" id="L662">        S_Expression saveTempExpr = tempExpr;</span>
<span class="fc" id="L663">        Range range = existsQuantifier.getRange();</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if (range != null) {</span>
<span class="fc" id="L665">            range.getLowerBound().accept(this);</span>
<span class="fc" id="L666">            saveTempExpr = new S_Expression(&quot;and&quot;, new S_Expression(</span>
<span class="fc" id="L667">                    &quot;&gt;=&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L668">            ), saveTempExpr);</span>
<span class="fc" id="L669">            range.getUpperBound().accept(this);</span>
<span class="fc" id="L670">            saveTempExpr = new S_Expression(&quot;and&quot;, new S_Expression(</span>
<span class="fc" id="L671">                    &quot;&lt;=&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L672">            ), saveTempExpr);</span>
        }
<span class="fc" id="L674">        saveTempExpr.replace(new VarDef(name, new IntegerType(), depth), var);</span>
<span class="fc" id="L675">        tempExpr = new S_Expression(&quot;exists&quot;, new Constant(variable), saveTempExpr);</span>
<span class="fc" id="L676">    }</span>

    @Override
    public void visit(ForAllQuantifier forAllQuantifier) {
<span class="fc" id="L680">        forAllQuantifier.getSubexpression1().accept(this);</span>
<span class="fc" id="L681">        noOfQuantifier += 1;</span>
<span class="fc" id="L682">        String name = forAllQuantifier.getIdentifier().toString();</span>
<span class="fc" id="L683">        int depth = forAllQuantifier.getDepth();</span>
<span class="fc" id="L684">        VarDef var = quantifierVar(forAllQuantifier.getPosition(), name, depth);</span>
<span class="fc" id="L685">        String variable = &quot;((&quot; + var.toString() + &quot; Int))&quot;;</span>
<span class="fc" id="L686">        S_Expression saveTempExpr = tempExpr;</span>
<span class="fc" id="L687">        Range range = forAllQuantifier.getRange();</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">        if (range != null) {</span>
<span class="fc" id="L689">            range.getLowerBound().accept(this);</span>
<span class="fc" id="L690">            saveTempExpr = new S_Expression(&quot;or&quot;, new S_Expression(</span>
<span class="fc" id="L691">                    &quot;&lt;&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L692">            ), saveTempExpr);</span>
<span class="fc" id="L693">            range.getUpperBound().accept(this);</span>
<span class="fc" id="L694">            saveTempExpr = new S_Expression(&quot;or&quot;, new S_Expression(</span>
<span class="fc" id="L695">                    &quot;&gt;&quot;, new VarDef(name, new IntegerType(), depth), tempExpr</span>
<span class="fc" id="L696">            ), saveTempExpr);</span>
        }
<span class="fc" id="L698">        saveTempExpr.replace(new VarDef(name, new IntegerType(), depth), var);</span>
<span class="fc" id="L699">        tempExpr = new S_Expression(&quot;forall&quot;, new Constant(variable), saveTempExpr);</span>
<span class="fc" id="L700">    }</span>
    
    private VarDef quantifierVar(Position position, String name, int depth) {
<span class="fc" id="L703">        String varDefName = &quot;$qvar&quot; + noOfQuantifier + 'l' + position.getLine()</span>
<span class="fc" id="L704">                    + 'c' + position.getColumn() + '$' + name;</span>
<span class="fc" id="L705">        return new VarDef(varDefName, new IntegerType(), depth);</span>
    }

    @Override
    public void visit(StatementBlock statementBlock) {
        //S_Expression expression = tempExpr;
<span class="fc" id="L711">        Statement[] statements = statementBlock.getStatements();</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">        for (int i = statements.length - 1; i &gt;= 0; i--) {</span>
            //change = false;
            //functionsCalled = new ArrayList&lt;FunctionCall&gt;();
            //noOfFuncCall = 0;
<span class="fc" id="L716">            statements[i].accept(this);</span>
            /*if (!functionsCalled.isEmpty()) {
                //int depth = upScopeReplacements.size() - 1;
                LinkedList&lt;S_Expression&gt; program = new LinkedList&lt;S_Expression&gt;();
                program.add(expression);
                programs.add(program);
                descriptions.add(new Pair&lt;KindOfProgram, Position&gt;(
                    KindOfProgram.FunctionEnsureToRemainingProgram,
                    statements[i].getPosition()));
                //prepareEndedLoop(program);
                tempExpr = new Constant(&quot;true&quot;);
                for (int j = 0; j &lt; functionsCalled.size(); j++) {
                    noOfFuncCall = j + 1;
                    afterFunctionCall(functionsCalled.get(j));
                }
                program.set(program.size() - 1, new S_Expression(&quot;assert&quot;,
                        new S_Expression(&quot;not&quot;,
                                program.getLast())));
                upScopeReplacements = new Stack&lt;HashMap&lt;VarDef, S_Expression&gt;&gt;();
                upScopeExpr = new Stack&lt;S_Expression&gt;();
                for (int j = 0; j &lt; depth; j++) {
                    upScopeReplacements.add(new HashMap&lt;VarDef, S_Expression&gt;());
                    upScopeExpr.add(new Constant(&quot;true&quot;));
                }
                change = true;
            }*/
            /*if (change) {
                expression = tempExpr;
            }
            tempExpr = expression; */
        }
        //functionsCalled = new ArrayList&lt;FunctionCall&gt;();
<span class="fc" id="L748">    }</span>

    private String getMangledArrayName(String name, boolean replace) {
<span class="nc" id="L751">        Integer tag = arrays.get(name);</span>
<span class="nc bnc" id="L752" title="All 4 branches missed.">        if (tag != null &amp;&amp; replace) tag = arrays.put(name, tag + 1);</span>
        else {
<span class="nc" id="L754">            arrays.put(name, 0);</span>
<span class="nc" id="L755">            tag = 0;</span>
        }
<span class="nc" id="L757">        return name + &quot;#&quot; + tag;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.6.201201232323</span>Coverage (07.03.2012 11:56:57)</div></body></html>