\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{calc}
\usepackage[section]{placeins}
\usepackage{tabularx}
\usepackage[vmargin=3cm, hmargin=2cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage{specifications}
\usepackage[ngerman]{babel}

\setlength{\parskip}{2pt}
\newlength{\imgwidth}
\newcommand\scalegraphics[1]{
  \settowidth{\imgwidth}{\includegraphics{#1}}
  \setlength{\imgwidth}{\minof{\imgwidth}{\textwidth}}
  \includegraphics[width=\imgwidth]{#1}
}

\newspec{Funktionale Anforderung}{FA}{f}
\newspec{Nicht-Funktionale Anforderungen}{NFA}{n}
\newspec{Produktdaten}{PD}{p}
\newspec{Globale Testf\"{a}lle}{T}{t}

\title{Pflichtenheft}
\author{Simon Bischof \and Jan Haag \and Adrian Herrmann \and Lin Jin \and Tobias Schlumberger \and Matthias Schnetz}

\makeindex

\begin{document}

\thispagestyle {empty}
\vspace*{4cm}
\begin{center}
\begin {huge}
Pflichtenheft\\
\end{huge}
Simon Bischof, Jan Haag, Adrian Herrmann, Lin Jin, Tobias Schlumberger, Matthias Schnetz\\
\vspace{3cm}
\begin{huge}
Praxis der Softwareentwicklung \\
Projekt 4:\\
Automatisches Pr\"{u}fen der Korrektheit von Programmen\\
Gruppe 1\\
\vspace{2cm}
\includegraphics[height=2cm]{images/Kitlogo_de_rgb.pdf}\\[0.5cm]
\end{huge}
\begin{huge}
WS 2011/2012
\end{huge}
\end{center}

\newpage
\tableofcontents
\newpage

\section{Produkt\"{u}bersicht}

%Das Produkt ist ein Werkzeug zur Analyse und Korrektheitspr\"{u}fung von Programmen. Der Benutzer hat die M\"{o}glichkeit, in eine grafische Oberfl\"{a}che ein Programm mit der im Anhang spezifizierten While-Sprache zu laden und mit Annotationen zu versehen, die als Vor- und Nachbedingungen gepr\"{u}ft werden.
Das Produkt ist ein Werkzeug zur Analyse und Korrektheitspr\"{u}fung von Programmen.

Der Benutzer interagiert \"{u}ber eine grafische Oberfl\"{a}che, die neben einem Editor f\"{u}r die Erstellung und Bearbeitung von Programmen auch detaillierte R\"{u}ckmeldungen zum aktuellen Programmzustand sowie weiterf\"{u}hrende Hilfen zur Verf\"{u}gung stellt.

Nach dem Erstellen eines Programms mit der im Anhang spezifizierten While-Sprache wird dieses zun\"{a}chst \"{u}bersetzt. \"{U}ber das Ergebnis dieser Analyse sowie eventuelle Fehler wird der Benutzer \"{u}ber die grafische Oberfl\"{a}che informiert.

Im Anschluss entsteht nach einer Erweiterung des Quelltextes um Annahmen in Form einer definierten Annotationssprache durch den Benutzer ein beweisbares Programm, welches mit den zur Verf\"{u}gung stehenden Methoden zur Analyse des Programms untersucht werden kann.

F\"{u}r diese Zwecke bietet das Produkt sowohl eine statische als auch dynamische Pr\"{u}fung des Programmes an. Bei der dynamischen Pr\"{u}fung kann der Benutzer Eingabeparameter frei w\"{a}hlen und das Programm mit diesen starten. W\"{a}hrend der Ausf\"{u}hrung werden die angegebenen Annotationen \"{u}berpr\"{u}ft. Im Fehlerfall wird das Programm im Fehlerzustand eingefroren und der Benutzer \"{u}ber die grafische Oberfl\"{a}che informiert.

Bei der statischen \"{U}berpr\"{u}fung wird versucht, die Annotationen als korrekt zu beweisen. Wenn der Beweis gelingt, gibt das Programm dem Benutzer dies \"{u}ber die grafische Oberfl\"{a}che bekannt; anderenfalls liefert das Programm ein Gegenbeispiel oder signalisiert, dass es keine Entscheidung treffen kann.

\section{Zielbestimmung}
\subsection{Interpreter / Run-time Checker}
\subsubsection{Musskriterien}
\begin{itemize}
  \item (schrittweise) Ausf\"{u}hrung eines Programms
  \item Inspektion des aktuellen Programmzustands durch den Benutzer
  \item Pr\"{u}fung von Zusicherungen in Programmen zur Laufzeit
\end{itemize}
\subsubsection{Sollkriterien}
\begin{itemize}
  \item Auswertung von Formeln mit Quantoren \"{u}ber eingeschr\"{a}nkten Bereich
\end{itemize}
\subsubsection{Kannkriterien}
\begin{itemize}
  \item Auswertung von benutzerdefinierten Ausdr\"{u}cken \"{u}ber Programmzustand
  \item Auswertung von Formeln mit Quantoren mit Hilfe eines Beweisers
  \item Breakpoints zum Halten der Ausf\"{u}hrung eines Programms an definierten Stellen
  \item Randomisiertes Testen in vorgegebenen Grenzen
\end{itemize}

\subsection{Grafische Benutzeroberfl\"{a}che}
\subsubsection{Musskriterien}
\begin{itemize}
  \item englische Sprache
  \item Steuerung der einzelnen Komponenten des Systems
  \item Anzeige von fehlgeschlagenen Laufzeitpr\"{u}fungen
  \item Speichern und Laden von Quelltexten
\end{itemize}
\subsubsection{Kannkriterien}
\begin{itemize}
  \item Syntax Highlighting
  \item Hilfe zur Syntax der While-Sprache und der Annotationssprache
  \item Markierung der aktuellen Zeile beim Halten der Ausf\"{u}hrung
\end{itemize}
\subsubsection{Abgrenzungskriterien}
\begin{itemize}
  \item Einstellungen bez\"{u}glich Schriftart, Schriftfarbe und Schriftgr\"{o}\ss{}e
  \item Projektmanagement
\end{itemize}

\subsection{Verifikation}
\subsubsection{Musskriterien}
\begin{itemize}
  \item formale Verifikation eines Programms mit Hilfe eines Beweisers
\end{itemize}

\subsection{While-Sprache}
\subsubsection{Musskriterien}
\begin{itemize}
  \item Zuweisungen, Bedingte Anweisungen und Schleifen
  \item Turing-Vollst\"{a}ndigkeit
\end{itemize}
\subsubsection{Kannkriterien}
\begin{itemize}
  \item Unterst\"{u}tzung von Methodenaufrufen
\end{itemize}
\subsubsection{Abgrenzungskriterien}
\begin{itemize}
  \item Variablentypen au\ss{}er Ganzzahl, Boolean und Arrays
  \item Implementierung eines Heaps
  \item Implementierung von Nebenl\"{a}ufigkeit
  \item \"{u}berladen von Methoden
\end{itemize}

\subsection{Annotationssprache}
\subsubsection{Musskriterien}
\begin{itemize}
  \item Ausdr\"{u}cke in Annotationen \"{a}hnlich wie in der Programmiersprache, zus\"{a}tzlich Quantoren
  \item Zusicherungen erlauben Aussagen der Pr\"{a}dikatenlogik
  \item Annotationen assert und assume
\end{itemize}
\subsubsection{Sollkriterien}
\begin{itemize}
  \item syntactic sugar f\"{u}r Vor- und Nachbedingungen, (In)Varianten und globale Annahmen
\end{itemize}


\section{Produkteinsatz}
Das Produkt erm\"{o}glicht dem Benutzer die Analyse eines Programmes, das in der im Anhang beschriebenen While-Sprache geschrieben ist. Dabei ist es sowohl m\"{o}glich, die Anweisungen des Programms schrittweise oder komplett zu durchlaufen und dabei zur Laufzeit auf im Programmcode durch Annotationen eingebettete Zusicherungen zu \"{u}berpr\"{u}fen, als auch die formale Verifikation des Programms mithilfe des automatischen Theorembeweisers Z3 von Microsoft.

\subsection{Anwendungsbereiche}
\begin{itemize}
  \item Formale Verifikation von Programmen
  \item Testen und Ausf\"{u}hren von Programmen der While-Sprache
\end{itemize}

\subsection{Zielgruppen}
\begin{itemize}
  \item Softwareentwickler / Anwendungsentwickler
\end{itemize}

\subsection{Betriebsbedingungen}
\begin{itemize}
  \item \"{u}bliche Beweiserlaufzeit: 1 Stunde
\end{itemize}

\section{Produktumgebung}
\subsection{Software}
\begin{itemize}
  \item Java Runtime Environment SE 6 oder h\"{o}her
  \item Windows NT 4.0 oder neuer oder Betriebssystem mit Wine
\end{itemize}

\subsection{Hardware}
\begin{itemize}
  \item mindestens 512 MB Arbeitsspeicher
\end{itemize}

\subsection{Schnittstellen}
\begin{itemize}
  \item Das Produkt erzeugt Dateien im SMT-LIB 2.0 Format als Schnittstelle zu Z3
\end{itemize}

\section{Funktionale Anforderungen}
\subsection{\"{U}bersicht}
\begin{tabular}{| l | l |}
\hline
\multicolumn{2}{| l |}{GUI}\\
\hline
/F1010/ & Anzeige von Quelltext\\
/F1020/ & Syntax Highlighting\\
/F1030/ & Ver\"{a}nderung des Quelltextes\\
/F1040/ & Speichern des Quelltextes in eine Datei\\
/F1050/ & Laden eines Programms aus einer Datei\\
/F1060/ & Anzeigen von Syntaxfehlern\\
/F1070/ & Anzeigen von Typfehlern\\
/F1080/ & Anzeigen von Laufzeitfehlern\\
/F1090/ & Setzen und Entfernen von Breakpoints\\
/F1100/ & Anzeige des Programmzustands\\
/F1110/ & Anhalten des Programmablaufs\\
/F1120/ & Fortsetzen des Programmablaufs\\
/F1130/ & Abbrechen des Programmablaufs\\
/F1140/ & Eingabe verschiedener Eingangskonfigurationen f\"{u}r Eingabeparameter\\
/F1150/ & Anzeige von fehlgeschlagenen Annotationsbedingungen\\
/F1160/ & Eingabe von benutzerdefinierten Ausdr\"{u}cken\\
/F1170/ & Anzeige der Beweisereinstellungen\\
/F1180/ & Laden der Beweisereinstellungen aus einer Datei\\
/F1190/ & Speichern der Beweisereinstellungen in eine Datei\\
/F1200/ & Starten des Beweisvorgangs\\
/F1210/ & Anzeige des Ergebnis des Beweisers\\
\hline
\multicolumn{2}{| l |}{Parser / Interpreter}\\
\hline
/F2010/ & Parsen des Quelltextes und Erzeugung eines AST\\
/F2020/ & Erkennen von Syntaxfehlern\\
/F2030/ & Erkennen von Typfehlern\\
/F2040/ & Ausf\"{u}hren eines Programms\\
/F2050/ & Anhalten der Ausf\"{u}hrung eines Programms\\
/F2060/ & Fortsetzung der Ausf\"{u}hrung eines Programms\\
/F2070/ & Abbrechen der Ausf\"{u}hrung eines Programms\\
/F2080/ & Ausf\"{u}hren einer einzelner Anweisung (Single Step)\\
/F2090/ & Anhalten des Programmablaufs bei einem Breakpoint\\
/F2100/ & Ausf\"{u}hrung eines Programms mit verschiedenen Belegungen f\"{u}r Eingabeparameter\\
/F2110/ & Anhalten des Programmablaufs bei einem Fehler\\
/F2120/ & Auswertung von benutzerdefinierten Ausdr\"{u}cken\\
/F2130/ & Auswertung der Ausdr\"{u}cke der Annotationssprache\\
\hline
\multicolumn{2}{| l |}{Beweiserschnittstelle}\\
\hline
/F3010/ & Quellcode in SMT-LIB 2.0 Format umwandeln\\
/F3020/ & \"{U}bergabe der benutzerdefinierten Einstellungen\\
/F3030/ & Beweiservorgang durchf\"{u}hren\\
\hline
\end{tabular}

\subsection{Details}
\subsubsection{GUI}
\begin{description}
\item[/F1010/] Anzeige von Quelltext\\
Der Benutzer sieht den Quelltext des aktuellen Programms in der grafischen Oberfl\"{a}che.
\item[/F1020/] Syntax Highlighting\\
Teile des angezeigten Quelltextes werden abh\"{a}ngig von ihrer Bedeutung in unterschiedlichen Farben angezeigt.
\newpage
\item[/F1030/] Ver\"{a}nderung des Quelltextes\\
Der Benutzer kann den angezeigten Quelltext ver\"{a}ndern oder einen neuen Quelltext eingeben.
\item[/F1040/] Speichern des Quelltextes in eine Datei\\
Der Benutzer kann den eingegebenen Quelltext in eine Datei speichern. Dabei gibt der Benutzer den gew\"{u}nschten Speicherort und den Dateinamen \"{u}ber eine grafische Oberfl\"{a}che an.
\item[/F1050/] Laden eines Programms aus einer Datei\\
Der Benutzer kann ein Quellcode eines Programms aus einer Datei laden. Hierbei gibt der Benutzer die zu ladende Datei \"{u}ber eine grafische Oberfl\"{a}che an.
\item[/F1060/] Anzeigen von Syntaxfehlern\\
Wenn der Interpreter Syntaxfehler erkannt hat ($\to$/F2020/), wird dies dem Benutzer angezeigt, wenn er die Programmausf\"{u}hrung oder die Beweisf\"{u}hrung anfordert.
\item[/F1070/] Anzeigen von Typfehlern\\
Wenn der Interpreter Typfehler erkannt hat ($\to$/F2030/), wird dies dem Benutzer angezeigt, wenn er die Programmausf\"{u}hrung oder die Beweisf\"{u}hrung anfordert.
\item[/F1080/] Anzeigen von Laufzeitfehlern\\
Wenn bei der Ausf\"{u}hrung eines Programmes durch den Interpreter ein Fehler auftritt ($\to$/F2050/), wird dies dem Benutzer angezeigt.
\item[/F1090/] Setzen und Entfernen von Breakpoints\\
Der Benutzer kann Breakpoints zur Pausierung eines Programmdurchlaufs an Stellen des angezeigten Quellcodes setzen und wieder entfernen.
\item[/F1100/] Anzeige des Programmzustands\\
Der Benutzer sieht w\"{a}hrend der Ausf\"{u}hrung eines Programms den aktuellen Inhalt aller globalen und lokalen Variablen. Die Anzeige wird nur aktualisiert, wenn das Programm die Ausf\"{u}hrung pausiert.
\item[/F1110/] Anhalten des Programmablaufs\\
Der Benutzer kann die Ausf\"{u}hrung eines Programms anhalten. Dabei wird der aktuelle Programmzustand beibehalten.
\item[/F1120/] Fortsetzen des Programmablaufs\\
Hat der Benutzer das Programm angehalten ($\to$/F1110/), so kann er die Ausf\"{u}hrung des Programms wieder aufnehmen.
\item[/F1130/] Abbrechen des Programmablaufs\\
Der Benutzer kann die Ausf\"{u}hrung eines Programms abbrechen. Dabei wird der Programmzustand verworfen.
\item[/F1140/] Eingabe verschiedener Eingangskonfigurationen f\"{u}r Eingabeparameter
Der Benutzer kann einen Zahlenbereich sowie eine Anzahl an Konfigurationen angeben. Das Programm wird anschlie\ss{}end mit diesen Konfigurationen automatisch mehrfach ausgef\"{u}hrt ($\to$/F2070/). Bei fehlerfreier Ausf\"{u}hrung wird dem Benutzer eine Auswertung der Durchl\"{a}ufe angezeigt, tritt bei einer Ausf\"{u}hrung ein Fehler auf, so wird die Ausf\"{u}hrung angehalten.
\item[/F1150/] Anzeige von fehlgeschlagenen Annotationsbedingungen\\
Meldet der Interpreter eine fehlgeschlagene Annotationsbedingung ($\to$/F2060/), so wird dies dem Benutzer angezeigt.
\item[/F1160/] Eingabe von benutzerdefinierten Ausdr\"{u}cken\\
Der Benutzer kann w\"{a}hrend der angehaltenen Ausf\"{u}hrung eines Programms Ausdr\"{u}cke eingeben, die vom Interpreter ausgewertet werden und deren Ergebnis dem Benutzer angezeigt wird.
\item[/F1170/] Anzeige der Beweisereinstellungen\\
Der Benutzer kann die aktuellen Einstellungen ($\to$/D10/) f\"{u}r die Ausf\"{u}hrung des Beweisers ($\to$/F1180/) anzeigen lassen. Diese werden vor der Anzeige aus einer Datei geladen ($\to$/F1160/) und bei einer Ver\"{a}nderung wieder in eine Datei geschrieben ($\to$/F1170/).
\item[/F1180/] Laden der Beweisereinstellungen aus einer Datei\\
Die Einstellungen f\"{u}r die Ausf\"{u}hrung des Beweisers ($\to$/D10/) werden automatisch aus einer Datei gelesen.
\item[/F1190/] Speichern der Beweisereinstellungen in eine Datei\\
Die Einstellungen ($\to$/D10/) werden in eine Datei gespeichert.
\item[/F1200/] Starten des Beweisvorgangs\\
Der Benutzer kann den Beweisvorgang mit Hilfe des Beweisers unter den eingegebenen Einstellungen starten.
\item[/F1210/] Anzeige des Ergebnis des Beweisers\\
Nach dem Durchlauf des Beweisers wird dem Benutzer das Ergebnis des Beweisvorgangs angezeigt.
\end{description}

\subsubsection{Parser / Interpreter}
\begin{description}
\item[/F2010/] Parsen des Quelltextes und Erzeugung eines AST\\
Der Parser analysiert den eingegebenen Quelltext und erzeugt daraus einen abstrakten Syntaxbaum zur Weiterverwendung f\"{u}r andere Programmkomponenten.
\item[/F2020/] Erkennen von Syntaxfehlern\\
Der Interpreter erkennt Syntaxfehler des eingegebenen Quelltextes.
\item[/F2030/] Erkennen von Typfehlern\\
Der Interpreter erkennt Typfehler des eingegebenen Quelltextes.
\item[/F2040/] Ausf\"{u}hren eines Programms\\
Ist der Quellcode frei von Syntaxfehlern ($\to$/F2020/) und von Typfehlern ($\to$/F2030/) Anweisungen im aktuell angezeigten Quelltext werden sequentiell ausgef\"{u}hrt.
\item[/F2050/] Anhalten der Ausf\"{u}hrung eines Programms\\
Die laufende Ausf\"{u}hrung eines Programms kann angehalten werden ($\to$/F1110/), wobei keine Anweisungen mehr ausgef\"{u}hrt werden und die Ausf\"{u}hrung im aktuellen Zustand stehen bleibt.
\item[/F2060/] Fortsetzung der Ausf\"{u}hrung eines Programms\\
Wurde ein Programm angehalten ($\to$/F2050/), so kann die Ausf\"{u}hrung mit dem Zustand zum Zeitpunkt der Pausierung fortgesetzt werden.
\item[/F2070/] Abbrechen der Ausf\"{u}hrung eines Programms\\
Die Ausf\"{u}hrung eines Programms kann angehalten werden ($\to$/F1120/), wobei der aktuelle Programmzustand verworfen wird.
\item[/F2080/] Ausf\"{u}hren einer einzelner Anweisung (Single Step)\\
Ist das Programm gestartet und angehalten, so wird die n\"{a}chste Anweisung ausgef\"{u}hrt. Ist das Programm nicht gestartet, so wird es gestartet ($\to$/F2040/).
\item[/F2090/] Anhalten des Programmablaufs bei einem Breakpoint\\
Wird bei der Ausf\"{u}hrung eines Programms ($\to$/F2040/) ein Breakpoint ($\to$/F1090/) erreicht, h\"{a}lt die Ausf\"{u}hrung an und der aktuelle Zustand wird zur\"{u}ckgegeben.
\item[/F2100/] Ausf\"{u}hrung eines Programms mit verschiedenen Belegungen f\"{u}r Eingabeparameter\\
Das Programm wird mehrmals nacheinander mit den Werten f\"{u}r die Eingabeparameter ausgef\"{u}hrt. Bei diesen Ausf\"{u}hrungen werden Breakpoints ($\to$/F1090/) ignoriert. Tritt bei einer Ausf\"{u}hrung ein Fehler auf, so wird die weitere Ausf\"{u}hrung angehalten. Tritt kein Fehler auf, so wird eine Auswertung der Ausf\"{u}hrungen erstellt.
\item[/F2110/] Anhalten des Programmablaufs bei einem Fehler\\
Tritt ein Fehler zur Laufzeit des Programms auf, wird die Ausf\"{u}hrung abgebrochen und der Fehler dem Benutzer angezeigt.
\item[/F2120/] Auswertung von benutzerdefinierten Ausdr\"{u}cken\\
Der Benutzer kann Ausdr\"{u}cke \"{u}ber den aktuellen Programmzustand auswerten lassen ($\to$/F1140/).
\item[/F2130/] Auswertung der Ausdr\"{u}cke der Annotationssprache\\
W\"{a}hrend der Programmausf\"{u}hrung werden die Bedingungen der Annotationssprache (einschlie\ss{}lich eventueller Quantoren) ausgewertet. Schl\"{a}gt eine \"{U}berpr\"{u}fung fehl, so wird die Ausf\"{u}hrung des Programms angehalten und dem Benutzer angezeigt, welche Bedingung falsch ist.
\end{description}

\subsubsection{Beweiserschnittstelle}
\begin{description}
\item[/F3010/] Quellcode in SMT-LIB 2.0 Format umwandeln\\
Das Produkt wandelt den aktuellen Quellcode zur Eingabe in den Beweiser in das SMT-LIB 2.0 Format um. Dies geschieht implizit durch das Starten des Beweisvorgangs in der grafischen Oberfl\"{a}che ($\to$/F1180/).
\item[/F3020/] \"{U}bergabe der benutzerdefinierten Einstellungen\\
Die vom Benutzer eingegebenen Einstellungen f\"{u}r den Beweisvorgang ($\to$/F1170/) werden dem Beweiser \"{u}bergeben.
\item[/F3030/] Beweiservorgang durchf\"{u}hren\\
Nach der Umwandlung des Quellcodes in das Eingabeformat des Beweisers ($\to$/F3010/) wird der Beweisvorgang f\"{u}r das aktuelle Programm wird durchgef\"{u}hrt und nach Abschluss das Ergebnis zur\"{u}ckgemeldet.
\end{description}


\section{Produktdaten}
Es sind folgende Daten des Benutzers zu Speichern:\\
\begin{description}
\item[/D10/] Benutzereinstellungen
\begin{itemize}
  \item Timeout in Sekunden f\"{u}r den Beweiser
  \item Speicherbegrenzung in Megabyte f\"{u}r den Beweiser
\end{itemize}
\item[/D20/] Zuletzt ge\"{o}ffnetes Verzeichnis
\begin{itemize}
  \item Das zuletzt durch /F1050/ ge\"{o}ffnete Verzeichnis.
\end{itemize}
\end{description}


\section{Produktleistungen}
\begin{itemize}
  \item Verifikation- und Falsifikationsr\"{u}ckmeldungen vom Beweiser bez\"{u}glich der Spezifikation m\"{u}ssen korrekt sein, in anderen F\"{a}llen soll dem Benutzer mitgeteilt werden, dass der Beweiser das Problem nicht l\"{o}sen kann
  \item Interpreter: Anweisungen mit weniger als 50 Operatoren werden in weniger als 0,1 Sekunde ausgef\"{u}hrt
  \item Parser: Programme mit 10.000 Zeilen werden in weniger als 1 Sekunde geparst
  \item vollst\"{a}ndige Dokumentation der Syntax der While- und Annotationssprache
\end{itemize}

\section{Weitere nichtfunktionale Anforderungen}
Die Lizenz von Z3 erlaubt ausschlie\ss{}lich eine nicht-kommerzielle Benutzung.
Die Benutzung von Z3 als Beweiser schr\"{a}nkt die Plattformunabh\"{a}ngigkeit auf Windows NT 4.0 und h\"{o}her und Betriebssysteme mit Wine ein. Durch Anbindung eines anderen Beweisers reicht unabh\"{a}ngig von den Anforderungen des neuen Beweisers eine aktuelle Java Runtime Environment.

\section{Qualit\"{a}tsanforderungen}
\begin{itemize}
  \item Programmiersprache muss erweiterbar sein
  \item m\"{o}gliche Anbindung anderer Beweiser, die das SMT-LIB 2.0 Format unterst\"{u}tzen
  \item unter (durch benutzerdefinierte Einstellungen vorgegebene, $\to$/F1150/) Normalbedingungen st\"{u}rzt das Produkt nicht ab
  \item jede Aktion gibt in jedem Fall eine R\"{u}ckmeldung an den Benutzer
\end{itemize}

\section{Globale Testf\"{a}lle und Testszenarien}
Folgende Funktionssequenzen sind zu \"{u}berpr\"{u}fen:\\
\begin{description}
\item[/T10/] Eingabe des leeren Programms $\to$ keine Syntaxfehler
\item[/T20/] Eingabe des leeren Programms ohne Annotationen, Beweisvorgang starten $\to$ Verifikation durch den Beweiser
\item[/T30/] Eingabe des leeren Programms, Annotation \texttt{ensure false}, Programmausf\"{u}hrung $\to$ Annotationsbedingung schl\"{a}gt fehl
\item[/T40/] Eingabe des leeren Programms, Annotation \texttt{ensure true}, Programmausf\"{u}hrung $\to$ Annotationsbedingung schl\"{a}gt nicht fehl
\item[/T50/] Eingabe eines beliebigen Programms, Annotation \texttt{require false}, Programmausf\"{u}hrung $\to$ Annotationsbedingung schl\"{a}gt fehl, Programmausf\"{u}hrung wird abgebrochen
\item[/T60/] Eingabe eines Programms mit Zuweisung \texttt{x = 1}, Annotation \texttt{require x>0}, Programmausf\"{u}hrung $\to$ Annotationsbedingung schl\"{a}gt nicht fehl
\item[/T70/] Eingabe eines Programms mit Syntaxfehler (z.B. fehlerhafte Klammerung, fehlendes Semikolon, Methodenname ist Keyword) $\to$ Anzeige des Syntaxfehlers
\item[/T80/] Eingabe eines Programms mit while-Schleife oder if-Konstrukt, deren Bedingung kein boolean ist $\to$ Anzeige des Typfehlers
\item[/T90/] Eingabe eines Programms mit einem Operator, der nur auf Ganzzahlen definiert ist und auf einen boolean angewendet wird $\to$ Anzeige des Typfehlers
\item[/T100/] Eingabe eines Programms mit einem Operator, der nur auf booleans definiert ist und auf Ganzzahlen angewendet wird $\to$ Anzeige des Typfehlers
\item[/T110/] Eingabe eines Programms mit einer Zuweisung eines boolean an eine Ganzzahl $\to$ Anzeige des Typfehlers
\item[/T120/] Eingabe eines Programms mit einer Zuweisung einer Ganzzahl an einen boolean $\to$ Anzeige des Typfehlers
\item[/T130/] Eingabe eines Programms mit einer Zuweisung einer Ganzzahl oder eines boolean an ein Array $\to$ Anzeige des Typfehlers
\item[/T140/] Eingabe eines Programms mit einem Vergleichsoperator, der auf zwei unterschiedliche Typen ausgef\"{u}hrt wird $\to$ Anzeige des Typfehlers
\item[/T150/] Eingabe eines Programms mit Zuweisung \texttt{y = 2x}, Annotation \texttt{ensure y==2x}, Beweisvorgang starten $\to$ Verifizierung durch den Beweiser
\item[/T160/] Eingabe eines Programms mit Zuweisung \texttt{y = 2x}, Annotation \texttt{ensure y\%2==0}, Beweisvorgang starten $\to$ Verifizierung durch den Beweiser
\item[/T170/] Eingabe eines l\"{a}ngeren Programms ohne Schleifen und ohne if-Konstrukt, Eingabe von Annotationen, die in jedem Fall wahr sind, Beweisvorgang starten $\to$ Verifizierung durch den Beweiser
\item[/T180/] Eingabe eines l\"{a}ngeren Programms ohne Schleifen und mit if-Konstrukt, Eingabe von Annotationen, die in jedem Fall wahr sind, Beweisvorgang starten $\to$ Verifizierung durch den Beweiser
\item[/T190/] Eingabe eines l\"{a}ngeren Programms mit Schleifen (z.B. russische Multiplikation, Maximum der Zahlen in einem Array), Eingabe von Annotationen, die in jedem Fall wahr sind, Beweisvorgang starten $\to$ Verifizierung durch den Beweiser
\item[/T200/] Eingabe eines Programms mit Annotation \texttt{ensure x!=x}, Beweisvorgang starten $\to$ Falsifikation durch den Beweiser
\item[/T210/] Eingabe eines l\"{a}ngeren Programms mit Schleife (z.B. russische Multiplikation, Maximum der Zahlen in einem Array), Eingabe von Annotationen, die in mindestens einem Fall falsch sind, Beweisvorgang starten $\to$ Falsifikation durch den Beweiser
\item[/T220/] Eingabe eines Programms mit Annotation \texttt{require x\%2==0}, Zuweisung \texttt{y = 2*(x/2)} und Annotation \texttt{ensure (x==y)}, Beweisvorgang starten $\to$ Verifikation durch den Beweiser
\item[/T230/] Eingabe eines Programms mit Division durch 0, Ausf\"{u}hrung des Programms $\to$ Anzeige des Laufzeitfehlers
\item[/T240/] Eingabe eines Programms mit Deklaration und Initialisierung eines Arrays, fehlerhafter Arrayzugriff, Ausf\"{u}hrung des Programms$\to$ Anzeige des Laufzeitfehlers
\end{description}


\section{Systemmodelle}
\subsection{Komponenten\"{u}bersicht}
\begin{figure}[h!]
\scalegraphics{images/overview2.png}
\end{figure}

\newpage
\subsection{Workflow}
\begin{figure}[h!]
\begin{center}
\scalegraphics{images/process.png}
\end{center}
\end{figure}


\section{Benutzeroberfl\"{a}che}
\subsection{\"{U}bersicht}
\begin{figure}[h!]
\scalegraphics{images/mockupf.png}
\end{figure}

\subsection{Men\"{u}punkte}
\begin{figure}[h!]
\begin{center}
\includegraphics[height=5.5cm]{images/menu1.png}
\end{center}
\end{figure}
\begin{figure}[h!]
\scalegraphics{images/menu2.png}
\end{figure}
\begin{figure}[h!]
\scalegraphics{images/menu3.png}
\end{figure}
\begin{figure}[h!]
\scalegraphics{images/menu4.png}
\end{figure}

\clearpage
\section{Spezielle Anforderungen an die Entwicklungsumgebung}
\begin{description}
  \item[Versionsverwaltung] Git (GitHub)
  \item[Kommunikation] E-Mail, GitHub Wiki
  \item[Dokumente] \LaTeXe
  \item[Programmiersprache] Java
  \item[UML-Diagramme] Dia, SD Edit (f\"{u}r Sequenzdiagramme)
  \item[Entwicklungsumgebung] keine einheitliche, Ausschluss entwicklungsumgebungsspezifischer Dateien durch .gitignore
  \item[Office-Paket] Microsoft Office
  \item[Bildbearbeitung] Paint.NET
\end{description}


\section{Zeit- und Ressourcenplanung}
\subsection{Phasenplan}
\begin{tabular}[h]{| l | l |}
\hline
\textbf{Phase} & \textbf{Zeit pro Person}\\
\hline
Pflichtenheft & 30 Stunden\\
Entwurf & 60 Stunden\\
Implementierung & 75 Stunden\\
Validierung & 45 Stunden\\
Abschlusspr\"{a}sentation & 30 Stunden\\
\hline
\end{tabular}

\subsection{Projektplan}
\begin{tabular}[h]{| l | l |}
\hline
\textbf{Komponente} & \textbf{Zeit}\\
\hline
GUI & 70 Stunden\\
Parser & 50 Stunden\\
Interpreter & 80 Stunden\\
Run-time Checker & 30 Stunden\\
Typchecker & 50 Stunden\\
Beweiseranbindung & 75 Stunden\\
\hline
\end{tabular}
\subsection{Phasenverantwortliche}
\begin{tabular}[h]{| l | r |}
\hline
\textbf{Phase} & \textbf{Verantwortliche(r)}\\
\hline
Pflichtenheft & Tobias\\
\hline
Entwurf & Adrian\\
\hline
Implementierung & Simon, Jan\\
\hline
Validierung & Lin\\
\hline
Abschlusspr\"{a}sentation & Matthias\\
\hline
\end{tabular}

\newpage
\section{Erg\"{a}nzungen}
\subsection{While-Sprache}
\subsubsection{Variablentypen}
\begin{description}
\item[Ganzzahl] ganze Zahl beliebiger Genauigkeit.
\item[Boolean] Wahrheitswert, entweder wahr oder falsch.
\item[Array] eine Zusammenfassung mehrerer Variablen eines Variablentyps. Die maximale Anzahl m\"{o}glicher Variablen in einem Array ist nach erster Festlegung konstant. Ein Array kann mehrdimensional sein, dann ist die Gr\"{\"{o}}\ss{}e jeder Dimension nach erster Festlegung konstant.
\end{description}
\subsubsection{Sprachkonstrukte}
\begin{tabularx}{\textwidth}{| l | X |}
\hline
\textbf{Konstrukt} & \textbf{Bedeutung}\\
\hline
sequentelle Komposition & Hintereinanderausf\"{u}hrung von Anweisungen.\\
\hline
if-else & Ausf\"{u}hrung bestimmter Anweisungen, falls eine Bedingung erf\"{u}llt ist. Ausf\"{u}hrung anderer Anweisungen, falls die Bedingung nicht erf\"{u}llt ist.\\
\hline
while & Wiederholte Ausf\"{u}hrung von bestimmten Anweisungen, wenn eine Bedingung erf\"{u}llt ist.\\
\hline
Methoden & Definition einer Folge von Anweisungen mit Parametern, die zu einem anderen Zeitpunkt im Programmablauf aufgerufen werden k\"{o}nnen, und einen Wert zur\"{u}ckgeben.\\
\hline
einzeilige Kommentare & Annotation, die keinen Einfluss auf die Quelltextverarbeitung haben.\\
\hline
Deklaration & Festlegung von Eigenschaften (Variablentyp, Bezeichner, \ldots) von Variablen und Methoden.\\
\hline
\end{tabularx}
\subsubsection{Operatoren}
\begin{tabularx}{\textwidth}{| l | X | l | X |}
\hline
\textbf{Operator} & \textbf{Eingabetypen} & \textbf{Ergebnistyp} & \textbf{Funktion}\\
\hline
\texttt{==} & 2 Variablen desselben Typs & Boolean & Pr\"{u}ft \texttt{T1} und \texttt{T2} auf Gleichheit, falls sie vom selben Variablentyp sind. Arrays sind gleich, wenn alle Elemente der tiefsten Ebene des Arrays gleich sind.\\
\texttt{!=} & 2 Variablen desselben Typs & Boolean & Pr\"{u}ft \texttt{T1} und \texttt{T2} auf Ungleichheit, falls sie vom selben Variablentyp sind. Liefert denselben Wert wie die Negation von \texttt{==}.\\
\texttt{=} & 1 Variable und ein Ausdruck & ? & Weist der Variable den Wert des Ausdrucks zu, wenn dieser Wert vom selben Variablentyp ist, wie die Variable.\\
\hline
\end{tabularx}
\clearpage
\begin{tabularx}{\textwidth}{| l | X | l | X |}
\hline
\textbf{Operator} & \textbf{Eingabetypen} & \textbf{Ergebnistyp} & \textbf{Funktion}\\
\hline
\texttt{<} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Boolean & Pr\"{u}ft, ob \texttt{Ganzzahl1} kleiner als \texttt{Ganzzahl2} ist.\\
\texttt{>} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Boolean & Pr\"{u}ft, ob \texttt{Ganzzahl1} gr\"{o}\ss{}er als \texttt{Ganzzahl2} ist.\\
\texttt{<=} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Boolean & Pr\"{u}ft, ob \texttt{Ganzzahl1} kleiner oder gleich \texttt{Ganzzahl2} ist.\\
\texttt{>=} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Boolean & Pr\"{u}ft, ob \texttt{Ganzzahl1} gr\"{o}\ss{}er oder gleich \texttt{Ganzzahl2} ist.\\
\texttt{+} & 1 Ganzzahl, \texttt{Ganzzahl} & Ganzzahl & Gibt \texttt{Ganzzahl} zur\"{u}ck.\\
\texttt{-} & 1 Ganzzahl, \texttt{Ganzzahl} & Ganzzahl & Gibt -\texttt{Ganzzahl} zur\"{u}ck.\\
\texttt{+} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Ganzzahl & Addiert \texttt{Ganzzahl1} und \texttt{Ganzzahl2}.\\
\texttt{-} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Ganzzahl & Subtrahiert \texttt{Ganzzahl2} von \texttt{Ganzzahl1}.\\
\texttt{*} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Ganzzahl & Multipliziert \texttt{Ganzzahl1} mit \texttt{Ganzzahl2}.\\
\texttt{/} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Ganzzahl & Dividiert \texttt{Ganzzahl1} durch \texttt{Ganzzahl2}. Das Ergebnis wird zur Null hin gerundet.\\
\texttt{\%} & 2 Ganzzahlen, \texttt{Ganzzahl1} und \texttt{Ganzzahl2} & Ganzzahl & Liefert den Rest der Ganzzahldivision von \texttt{Ganzzahl1} durch \texttt{Ganzzahl2}.\\
\hline
\texttt{!} & 1 Boolean, \texttt{Boolean} & Boolean & Negiert den Wert von \texttt{Boolean}.\\
\texttt{\&} & 2 Boolean, \texttt{Boolean1} und \texttt{Boolean2} & Boolean & Liefert die Konjunktion von \texttt{Boolean1} und \texttt{Boolean2}.\\
\texttt{|} & 2 Boolean, \texttt{Boolean1} und \texttt{Boolean2} & Boolean & Liefert die Disjunktion von \texttt{Boolean1} und \texttt{Boolean2}.\\
\hline
\end{tabularx}
\subsubsection{Sonstige Spracheigenschaften}
\begin{itemize}
  \item Lexical Scoping
  \item Kurzauswertung von logischen Operatoren
\end{itemize}


\subsection{Annotationssprache}
Die Annotationssprache besteht aus Ausdr\"{u}cken der While-Sprache mit Quantoren und zus\"{a}tzlich den folgenden Konstrukten:\\
\begin{tabularx}{\textwidth}{| l | X |}
\hline
\texttt{require} & Stellt eine Vorbedingung vor Schleifen oder Methoden dar.\\
\texttt{ensure} & Stellt eine Nachbedingung nach Schleifen oder Methoden dar.\\
\texttt{assert} & Stellt eine Bedingung an der aktuellen Stelle im Programmablauf dar.\\
\texttt{assume} & Stellt eine als wahr angenommene Aussage dar, die ab dem Punkt der Programmausf\"{u}hrung gilt, an der die Annotation steht.\\
\texttt{invariant} & Stellt eine Invariante einer Schleife dar.\\
\hline
\texttt{thereis} & Existenzquantor $\exists$\\
\texttt{forall} & Allquantor $\forall$\\
\hline
\end{tabularx}

\newpage
\section{Glossar}
\begin{description}
\item[Anweisung (Programm)] Eine syntaktisch korrekte Vorschrift, die bei der Abarbeitung des Programms auszuf\"{u}hren ist.
\item[AST] Abstract Syntax Tree, eine Datenstruktur zur Darstellung der syntaktischen Struktur eines Programmcodes.
\item[Beweiser] Ein Programm, das versucht die G\"{u}ltigkeit eines Theorems zu \"{u}berpr\"{u}fen. Ein Beispiel f\"{u}r ein solches Programm ist $\to$Z3.
\item[Breakpoint] Ein Haltepunkt im Programm, bei der die Ausf\"{u}hrung eines Programms angehalten wird, sobald diese Stelle erreicht wird.
\item[GUI] Graphical User Interface, grafische Benutzeroberfl\"{a}che.
\item[Interpreter] Ein Programm, das Quellcode ausf\"{u}hren kann.
\item[Kurzauswertung] Die Auswertung eines Ausdrucks wird abgebrochen, sobald der Wert des Ausdrucks bekannt ist.
\item[Lexical Scoping] Auf eine lokale Variable kann nur in ihrem lexikalischen Sichtbarkeitsbereich Bezug genommen werden.
\item[Parser] Ein Programm, das einen Quelltext in eine f\"{u}r die Weiterverarbeitung g\"{u}nstiges Format (z.B. $\to$AST) umwandelt.
\item[Pr\"{a}dikatenlogik] Ein logisches System, das es erm\"{o}glicht Argumente zu formalisieren und auf ihre G\"{u}ltigkeit zu pr\"{u}fen.
\item[Run-time checker] Programmkomponente, die Bedingungen zur Laufzeit eines Programms \"{u}berpr\"{u}ft.
\item[sequentielle Komposition] Hintereinanderausf\"{u}hrung von mehreren Anweisungen.
\item[SMT-LIB 2.0] Ein Standardformat zur Beschreibung von Satisfiability Modulo Theories Problemen, d.h. Formeln der Pr\"{a}dikatenlogik erster Stufe.
\item[syntactic sugar] Syntaxelemente einer Programmiersprache, die nur der Komfortabilit\"{a}t dienen. Diese Syntaxelemente k\"{o}nnen aus der Sprache entfernt werden, ohne die Funktionalit\"{a}t einzuschr\"{a}nken.
\item[While-Sprache] Eine Programmiersprache, die sich durch einfache und wenige Kontrollstrukturen auszeichnet.
\item[Z3] Ein $\to$Beweiser von Microsoft.
\end{description}

\end{document}
